// ========================================
// MARIANA GOMEZ - M√ìDULO DE PROYECTOS
// ========================================

// src/models/Project.model.js - Modelo de Proyectos
const mongoose = require('mongoose');

const projectSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'El nombre del proyecto es requerido'],
    trim: true,
    maxlength: [100, 'El nombre no puede exceder 100 caracteres']
  },
  description: {
    type: String,
    required: [true, 'La descripci√≥n es requerida'],
    maxlength: [1000, 'La descripci√≥n no puede exceder 1000 caracteres']
  },
  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    required: [true, 'La categor√≠a es requerida']
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'El propietario es requerido']
  },
  members: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    role: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Role',
      required: true
    },
    joinedAt: {
      type: Date,
      default: Date.now
    },
    permissions: [{
      type: String,
      enum: ['read', 'write', 'manage', 'delete']
    }]
  }],
  status: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'State',
    required: true
  },
  priority: {
    type: String,
    enum: ['Low', 'Medium', 'High', 'Critical'],
    default: 'Medium'
  },
  startDate: {
    type: Date,
    required: [true, 'La fecha de inicio es requerida']
  },
  endDate: {
    type: Date,
    required: [true, 'La fecha de fin es requerida'],
    validate: {
      validator: function(endDate) {
        return endDate > this.startDate;
      },
      message: 'La fecha de fin debe ser posterior a la fecha de inicio'
    }
  },
  estimatedHours: {
    type: Number,
    min: [0, 'Las horas estimadas deben ser positivas'],
    default: 0
  },
  actualHours: {
    type: Number,
    min: [0, 'Las horas reales deben ser positivas'],
    default: 0
  },
  budget: {
    type: Number,
    min: [0, 'El presupuesto debe ser positivo'],
    default: 0
  },
  progress: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },
  isActive: {
    type: Boolean,
    default: true
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: [20, 'Los tags no pueden exceder 20 caracteres']
  }],
  attachments: [{
    filename: String,
    originalName: String,
    path: String,
    mimetype: String,
    size: Number,
    uploadedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual para calcular progreso basado en tareas
projectSchema.virtual('completionPercentage').get(function() {
  return this.progress;
});

// Virtual para verificar si est√° retrasado
projectSchema.virtual('isOverdue').get(function() {
  return this.endDate < new Date() && this.status !== 'Completado';
});

// Virtual para d√≠as restantes
projectSchema.virtual('daysRemaining').get(function() {
  const today = new Date();
  const diffTime = this.endDate - today;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Middleware para validar miembros √∫nicos
projectSchema.pre('save', function(next) {
  const userIds = this.members.map(member => member.user.toString());
  const uniqueUserIds = [...new Set(userIds)];
  
  if (userIds.length !== uniqueUserIds.length) {
    return next(new Error('No se pueden tener miembros duplicados'));
  }
  
  next();
});

// √çndices para optimizaci√≥n
projectSchema.index({ name: 1 });
projectSchema.index({ owner: 1 });
projectSchema.index({ category: 1 });
projectSchema.index({ status: 1 });
projectSchema.index({ 'members.user': 1 });
projectSchema.index({ isActive: 1 });
projectSchema.index({ startDate: 1, endDate: 1 });
projectSchema.index({ tags: 1 });

// √çndice compuesto para b√∫squedas complejas
projectSchema.index({
  name: 'text',
  description: 'text',
  tags: 'text'
}, {
  weights: {
    name: 10,
    description: 5,
    tags: 1
  }
});

module.exports = mongoose.model('Project', projectSchema);

// ========================================
// src/controllers/project.controller.js - Controlador de Proyectos
// ========================================
const Project = require('../models/Project.model');
const State = require('../models/State.model');
const Category = require('../models/Category.model');
const User = require('../models/User.model');
const { sendResponse, sendError, createPagination } = require('../utils/response.util');

class ProjectController {
  // Obtener proyectos del usuario
  async getProjects(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = Math.min(parseInt(req.query.limit) || 10, 50);
      const skip = (page - 1) * limit;
      
      const { search, category, status, priority, owner } = req.query;

      // Construir filtros
      const filter = {
        isActive: true,
        $or: [
          { owner: req.user._id },
          { 'members.user': req.user._id }
        ]
      };

      // Filtro de b√∫squeda
      if (search) {
        filter.$text = { $search: search };
      }

      // Filtros adicionales
      if (category) filter.category = category;
      if (status) filter.status = status;
      if (priority) filter.priority = priority;
      if (owner) filter.owner = owner;

      const projects = await Project.find(filter)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name color icon')
        .populate('status', 'name color')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name')
        .select('-attachments') // Excluir archivos adjuntos para mejor performance
        .skip(skip)
        .limit(limit)
        .sort({ updatedAt: -1 });

      const total = await Project.countDocuments(filter);

      sendResponse(res, 200, true, 'Proyectos obtenidos exitosamente', {
        projects,
        pagination: createPagination(page, limit, total)
      });
    } catch (error) {
      console.error('Error obteniendo proyectos:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Crear nuevo proyecto
  async createProject(req, res) {
    try {
      const {
        name,
        description,
        category,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags
      } = req.body;

      // Verificar que la categor√≠a existe
      const categoryExists = await Category.findById(category);
      if (!categoryExists || !categoryExists.isActive) {
        return sendError(res, 400, 'Categor√≠a no v√°lida');
      }

      // Obtener estado inicial para proyectos
      const initialState = await State.findOne({
        type: 'Project',
        isInitial: true,
        isActive: true
      });

      if (!initialState) {
        return sendError(res, 500, 'No se encontr√≥ estado inicial para proyectos');
      }

      // Crear proyecto
      const project = await Project.create({
        name,
        description,
        category,
        owner: req.user._id,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags,
        status: initialState._id,
        members: [{
          user: req.user._id,
          role: req.user.globalRole,
          permissions: ['read', 'write', 'manage', 'delete']
        }]
      });

      // Poblar relaciones
      await project.populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name color icon' },
        { path: 'status', select: 'name color' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 201, true, 'Proyecto creado exitosamente', { project });
    } catch (error) {
      console.error('Error creando proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Obtener proyecto espec√≠fico
  async getProject(req, res) {
    try {
      const { id } = req.params;

      const project = await Project.findById(id)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name color icon description')
        .populate('status', 'name color description')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name description')
        .populate('attachments.uploadedBy', 'firstName lastName');

      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos
      const isMember = this.checkProjectMembership(project, req.user._id);
      if (!isMember) {
        return sendError(res, 403, 'No tienes permisos para ver este proyecto');
      }

      sendResponse(res, 200, true, 'Proyecto obtenido exitosamente', { project });
    } catch (error) {
      console.error('Error obteniendo proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar proyecto
  async updateProject(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos de edici√≥n
      const hasPermission = this.checkProjectPermission(project, req.user._id, 'manage');
      if (!hasPermission) {
        return sendError(res, 403, 'No tienes permisos para editar este proyecto');
      }

      // Validar categor√≠a si se est√° actualizando
      if (updateData.category) {
        const categoryExists = await Category.findById(updateData.category);
        if (!categoryExists || !categoryExists.isActive) {
          return sendError(res, 400, 'Categor√≠a no v√°lida');
        }
      }

      // Validar fechas
      if (updateData.startDate && updateData.endDate) {
        if (new Date(updateData.endDate) <= new Date(updateData.startDate)) {
          return sendError(res, 400, 'La fecha de fin debe ser posterior a la fecha de inicio');
        }
      }

      const updatedProject = await Project.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      ).populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name color icon' },
        { path: 'status', select: 'name color' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Proyecto actualizado exitosamente', {
        project: updatedProject
      });
    } catch (error) {
      console.error('Error actualizando proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Agregar miembro al proyecto
  async addMember(req, res) {
    try {
      const { id } = req.params;
      const { userId, roleId, permissions = ['read'] } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo el owner o admins pueden agregar miembros
      const isOwner = project.owner.toString() === req.user._id.toString();
      const isAdmin = req.user.globalRole.name === 'Admin';
      
      if (!isOwner && !isAdmin) {
        return sendError(res, 403, 'Solo el propietario o admin pueden agregar miembros');
      }

      // Verificar que el usuario existe
      const userExists = await User.findById(userId);
      if (!userExists || !userExists.isActive) {
        return sendError(res, 400, 'Usuario no v√°lido');
      }

      // Verificar que no sea ya miembro
      const isAlreadyMember = project.members.some(
        member => member.user.toString() === userId
      );

      if (isAlreadyMember) {
        return sendError(res, 400, 'El usuario ya es miembro del proyecto');
      }

      // Agregar miembro
      project.members.push({
        user: userId,
        role: roleId,
        permissions
      });

      await project.save();

      // Poblar y retornar proyecto actualizado
      await project.populate([
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Miembro agregado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          members: project.members
        }
      });
    } catch (error) {
      console.error('Error agregando miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Remover miembro del proyecto
  async removeMember(req, res) {
    try {
      const { id, userId } = req.params;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo el owner puede remover miembros
      const isOwner = project.owner.toString() === req.user._id.toString();
      if (!isOwner) {
        return sendError(res, 403, 'Solo el propietario puede remover miembros');
      }

      // No se puede remover al owner
      if (userId === project.owner.toString()) {
        return sendError(res, 400, 'No se puede remover al propietario del proyecto');
      }

      // Remover miembro
      project.members = project.members.filter(
        member => member.user.toString() !== userId
      );

      await project.save();

      sendResponse(res, 200, true, 'Miembro removido exitosamente');
    } catch (error) {
      console.error('Error removiendo miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Cambiar estado del proyecto
  async changeStatus(req, res) {
    try {
      const { id } = req.params;
      const { statusId } = req.body;

      const project = await Project.findById(id).populate('status');
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos
      const hasPermission = this.checkProjectPermission(project, req.user._id, 'manage');
      if (!hasPermission) {
        return sendError(res, 403, 'No tienes permisos para cambiar el estado');
      }

      // Verificar que el nuevo estado existe
      const newStatus = await State.findById(statusId);
      if (!newStatus || !newStatus.isActive || newStatus.type !== 'Project') {
        return sendError(res, 400, 'Estado no v√°lido');
      }

      // Verificar transici√≥n v√°lida
      const currentStatus = await State.findById(project.status).populate('allowedTransitions');
      const isValidTransition = currentStatus.allowedTransitions.some(
        transition => transition._id.toString() === statusId
      ) || currentStatus._id.toString() === statusId; // Permitir mismo estado

      if (!isValidTransition && currentStatus.allowedTransitions.length > 0) {
        return sendError(res, 400, 'Transici√≥n de estado no v√°lida');
      }

      project.status = statusId;
      
      // Si el estado es final, marcar progreso como 100%
      if (newStatus.isFinal) {
        project.progress = 100;
      }

      await project.save();
      await project.populate('status', 'name color description');

      sendResponse(res, 200, true, 'Estado cambiado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          status: project.status,
          progress: project.progress
        }
      });
    } catch (error) {
      console.error('Error cambiando estado:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Obtener estad√≠sticas del proyecto
  async getProjectStats(req, res) {
    try {
      const userId = req.user._id;

      // Proyectos donde es owner o miembro
      const projectFilter = {
        isActive: true,
        $or: [
          { owner: userId },
          { 'members.user': userId }
        ]
      };

      const totalProjects = await Project.countDocuments(projectFilter);

      // Estad√≠sticas por estado
      const statusStats = await Project.aggregate([
        { $match: projectFilter },
        {
          $lookup: {
            from: 'states',
            localField: 'status',
            foreignField: '_id',
            as: 'statusInfo'
          }
        },
        { $unwind: '$statusInfo' },
        {
          $group: {
            _id: '$statusInfo.name',
            count: { $sum: 1 },
            color: { $first: '$statusInfo.color' }
          }
        }
      ]);

      // Estad√≠sticas por prioridad
      const priorityStats = await Project.aggregate([
        { $match: projectFilter },
        {
          $group: {
            _id: '$priority',
            count: { $sum: 1 }
          }
        }
      ]);

      // Proyectos pr√≥ximos a vencer (7 d√≠as)
      const upcomingDeadlines = await Project.find({
        ...projectFilter,
        endDate: {
          $gte: new Date(),
          $lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        }
      })
      .populate('status', 'name color')
      .select('name endDate status progress')
      .sort({ endDate: 1 })
      .limit(5);

      sendResponse(res, 200, true, 'Estad√≠sticas obtenidas exitosamente', {
        stats: {
          totalProjects,
          statusStats,
          priorityStats,
          upcomingDeadlines
        }
      });
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // M√©todos auxiliares para verificar permisos
  checkProjectMembership(project, userId) {
    const isOwner = project.owner.toString() === userId.toString();
    const isMember = project.members.some(
      member => member.user.toString() === userId.toString()
    );
    return isOwner || isMember;
  }

  checkProjectPermission(project, userId, permission) {
    const isOwner = project.owner.toString() === userId.toString();
    if (isOwner) return true;

    const member = project.members.find(
      member => member.user.toString() === userId.toString()
    );

    return member && member.permissions.includes(permission);
  }
}

module.exports = new ProjectController();

// ========================================
// src/routes/project.routes.js - Rutas de Proyectos
// ========================================
const express = require('express');
const router = express.Router();
const projectController = require('../controllers/project.controller');
const { authenticate } = require('../middlewares/auth.middleware');
const { authorize } = require('../middlewares/role.middleware');
const { validateProject, validateMember, validateStatus } = require('../validators/project.validator');
const { validateRequest } = require('../middlewares/validation.middleware');

// Todas las rutas requieren autenticaci√≥n
router.use(authenticate);

// Rutas principales
router.get('/', projectController.getProjects);
router.post('/', authorize(['Admin', 'Project Manager']), validateProject, validateRequest, projectController.createProject);
router.get('/stats', projectController.getProjectStats);
router.get('/:id', projectController.getProject);
router.put('/:id', validateProject, validateRequest, projectController.updateProject);
router.delete('/:id', authorize(['Admin']), projectController.deleteProject);

// Rutas de miembros
router.post('/:id/members', validateMember, validateRequest, projectController.addMember);
router.delete('/:id/members/:userId', projectController.removeMember);

// Rutas de estado
router.put('/:id/status', validateStatus, validateRequest, projectController.changeStatus);

module.exports = router;

// ========================================
// src/validators/project.validator.js - Validaciones de Proyectos
// ========================================
const { body, param } = require('express-validator');
const mongoose = require('mongoose');

const validateProject = [
  body('name')
    .trim()
    .isLength({ min: 3, max: 100 })
    .withMessage('El nombre debe tener entre 3 y 100 caracteres'),

  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('La descripci√≥n debe tener entre 10 y 1000 caracteres'),

  body('category')
    .isMongoId()
    .withMessage('ID de categor√≠a inv√°lido'),

  body('startDate')
    .isISO8601()
    .withMessage('Fecha de inicio inv√°lida'),

  body('endDate')
    .isISO8601()
    .withMessage('Fecha de fin inv√°lida')
    .custom((endDate, { req }) => {
      if (new Date(endDate) <= new Date(req.body.startDate)) {
        throw new Error('La fecha de fin debe ser posterior a la fecha de inicio');
      }
      return true;
    }),

  body('estimatedHours')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Las horas estimadas deben ser un n√∫mero positivo'),

  body('budget')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('El presupuesto debe ser un n√∫mero positivo'),

  body('priority')
    .optional()
    .isIn(['Low', 'Medium', 'High', 'Critical'])
    .withMessage('Prioridad inv√°lida'),

  body('tags')
    .optional()
    .isArray()
    .withMessage('Los tags deben ser un array'),

  body('tags.*')
    .optional()
    .isLength({ min: 1, max: 20 })
    .withMessage('Cada tag debe tener entre 1 y 20 caracteres')
];

const validateMember = [
  body('userId')
    .isMongoId()
    .withMessage('ID de usuario inv√°lido'),

  body('roleId')
    .isMongoId()
    .withMessage('ID de rol inv√°lido'),

  body('permissions')
    .optional()
    .isArray()
    .withMessage('Los permisos deben ser un array'),

  body('permissions.*')
    .optional()
    .isIn(['read', 'write', 'manage', 'delete'])
    .withMessage('Permiso inv√°lido')
];

const validateStatus = [
  body('statusId')
    .isMongoId()
    .withMessage('ID de estado inv√°lido')
];

const validateObjectId = [
  param('id')
    .isMongoId()
    .withMessage('ID de proyecto inv√°lido')
];

module.exports = {
  validateProject,
  validateMember,
  validateStatus,
  validateObjectId
};

// ========================================
// src/middlewares/role.middleware.js - Middleware de Roles
// ========================================
const { sendError } = require('../utils/response.util');

/**
 * Middleware para autorizar roles espec√≠ficos
 * @param {Array} allowedRoles - Roles permitidos
 */
const authorize = (allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return sendError(res, 401, 'Usuario no autenticado');
    }

    const userRole = req.user.globalRole.name;
    
    if (!allowedRoles.includes(userRole)) {
      return sendError(res, 403, 'No tienes permisos suficientes para esta acci√≥n');
    }

    next();
  };
};

/**
 * Middleware para verificar permisos espec√≠ficos en recursos
 * @param {String} resource - Recurso (projects, tasks, etc.)
 * @param {String} action - Acci√≥n (create, read, update, delete)
 */
const checkPermission = (resource, action) => {
  return (req, res, next) => {
    if (!req.user) {
      return sendError(res, 401, 'Usuario no autenticado');
    }

    const userRole = req.user.globalRole;
    
    // Admins tienen todos los permisos
    if (userRole.name === 'Admin') {
      return next();
    }

    // Verificar permisos espec√≠ficos del rol
    const hasPermission = userRole.permissions.some(permission => 
      permission.resource === resource && 
      (permission.actions.includes(action) || permission.actions.includes('manage'))
    );

    if (!hasPermission) {
      return sendError(res, 403, 'No tienes permisos para esta acci√≥n');
    }

    next();
  };
};

/**
 * Middleware para verificar ownership de un recurso
 * @param {String} resourceModel - Modelo del recurso
 * @param {String} ownerField - Campo que indica el propietario
 */
const checkOwnership = (resourceModel, ownerField = 'owner') => {
  return async (req, res, next) => {
    try {
      const { id } = req.params;
      const Model = require(`../models/${resourceModel}.model`);
      
      const resource = await Model.findById(id);
      if (!resource) {
        return sendError(res, 404, 'Recurso no encontrado');
      }

      const isOwner = resource[ownerField].toString() === req.user._id.toString();
      const isAdmin = req.user.globalRole.name === 'Admin';

      if (!isOwner && !isAdmin) {
        return sendError(res, 403, 'Solo el propietario puede realizar esta acci√≥n');
      }

      req.resource = resource;
      next();
    } catch (error) {
      console.error('Error verificando ownership:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  };
};

module.exports = {
  authorize,
  checkPermission,
  checkOwnership
};

// ========================================
// tests/projects.test.js - Tests de Proyectos
// ========================================
const request = require('supertest');
const app = require('../server');
const Project = require('../src/models/Project.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const User = require('../src/models/User.model');
const Role = require('../src/models/Role.model');

describe('Project Endpoints', () => {
  let authToken;
  let testUser;
  let testCategory;
  let testState;
  let pmRole;

  beforeAll(async () => {
    // Crear rol Project Manager
    pmRole = await Role.create({
      name: 'Project Manager',
      description: 'Gestor de proyectos',
      permissions: [
        { resource: 'projects', actions: ['create', 'read', 'update', 'manage'] }
      ]
    });

    // Crear usuario de prueba
    testUser = await User.create({
      firstName: 'Test',
      lastName: 'PM',
      email: 'pm@test.com',
      password: 'password123',
      globalRole: pmRole._id,
      isEmailVerified: true
    });

    // Crear categor√≠a de prueba
    testCategory = await Category.create({
      name: 'Test Category',
      description: 'Categor√≠a de prueba',
      createdBy: testUser._id
    });

    // Crear estado de prueba
    testState = await State.create({
      name: 'Planificaci√≥n',
      type: 'Project',
      isInitial: true,
      color: '#ffc107'
    });

    // Obtener token
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'pm@test.com',
        password: 'password123'
      });

    authToken = loginResponse.body.data.tokens.accessToken;
  });

  beforeEach(async () => {
    await Project.deleteMany({});
  });

  describe('POST /api/projects', () => {
    test('Should create a new project', async () => {
      const projectData = {
        name: 'Test Project',
        description: 'This is a test project description',
        category: testCategory._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 d√≠as despu√©s
        estimatedHours: 100,
        budget: 5000,
        priority: 'High',
        tags: ['test', 'demo']
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(projectData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.project.name).toBe(projectData.name);
      expect(response.body.data.project.owner._id).toBe(testUser._id.toString());
    });

    test('Should not create project with invalid data', async () => {
      const invalidProjectData = {
        name: 'A', // Muy corto
        description: 'Short', // Muy corto
        category: 'invalid-id',
        startDate: new Date(),
        endDate: new Date(Date.now() - 24 * 60 * 60 * 1000) // Fecha anterior
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidProjectData);

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/projects', () => {
    beforeEach(async () => {
      // Crear proyecto de prueba
      await Project.create({
        name: 'Test Project',
        description: 'Test project description',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: ['read', 'write', 'manage']
        }]
      });
    });

    test('Should get user projects', async () => {
      const response = await request(app)
        .get('/api/projects')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.projects).toHaveLength(1);
      expect(response.body.data.pagination).toBeDefined();
    });

    test('Should filter projects by search', async () => {
      const response = await request(app)
        .get('/api/projects?search=Test')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.data.projects).toHaveLength(1);
    });
  });

  describe('PUT /api/projects/:id/status', () => {
    let testProject;
    let newState;

    beforeEach(async () => {
      // Crear nuevo estado
      newState = await State.create({
        name: 'En Progreso',
        type: 'Project',
        color: '#007bff'
      });

      // Configurar transiciones permitidas
      testState.allowedTransitions = [newState._id];
      await testState.save();

      // Crear proyecto
      testProject = await Project.create({
        name: 'Test Project',
        description: 'Test project description',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: ['read', 'write', 'manage']
        }]
      });
    });

    test('Should change project status', async () => {
      const response = await request(app)
        .put(`/api/projects/${testProject._id}/status`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ statusId: newState._id });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
    });
  });
});

// ========================================
// Archivo de configuraci√≥n espec√≠fico para Mariana
// ========================================
// scripts/seed-projects.js - Script para datos de prueba
const mongoose = require('mongoose');
const Project = require('../src/models/Project.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const User = require('../src/models/User.model');
require('dotenv').config();

const seedProjects = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Conectado a MongoDB');

    // Obtener datos necesarios
    const category = await Category.findOne({ name: 'Desarrollo Web' });
    const state = await State.findOne({ type: 'Project', isInitial: true });
    const user = await User.findOne({ email: { $exists: true } });

    if (!category || !state || !user) {
      console.log('Faltan datos b√°sicos. Ejecuta primero los seeds de usuarios, categor√≠as y estados.');
      return;
    }

    // Crear proyectos de ejemplo
    const sampleProjects = [
      {
        name: 'Sistema de Gesti√≥n de Inventario',
        description: 'Desarrollo de un sistema web para gesti√≥n de inventario con funcionalidades de tracking en tiempo real.',
        category: category._id,
        owner: user._id,
        status: state._id,
        priority: 'High',
        startDate: new Date(),
        endDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000), // 60 d√≠as
        estimatedHours: 200,
        budget: 15000,
        tags: ['web', 'inventory', 'real-time'],
        members: [{
          user: user._id,
          role: user.globalRole,
          permissions: ['read', 'write', 'manage', 'delete']
        }]
      },
      {
        name: 'App M√≥vil de E-commerce',
        description: 'Aplicaci√≥n m√≥vil para plataforma de comercio electr√≥nico con integraci√≥n de pagos.',
        category: category._id,
        owner: user._id,
        status: state._id,
        priority: 'Critical',
        startDate: new Date(),
        endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 d√≠as
        estimatedHours: 300,
        budget: 25000,
        tags: ['mobile', 'ecommerce', 'payments'],
        members: [{
          user: user._id,
          role: user.globalRole,
          permissions: ['read', 'write', 'manage', 'delete']
        }]
      },
      {
        name: 'Dashboard de Analytics',
        description: 'Dashboard interactivo para visualizaci√≥n de m√©tricas y an√°lisis de datos empresariales.',
        category: category._id,
        owner: user._id,
        status: state._id,
        priority: 'Medium',
        startDate: new Date(),
        endDate: new Date(Date.now() + 45 * 24 * 60 * 60 * 1000), // 45 d√≠as
        estimatedHours: 150,
        budget: 12000,
        tags: ['dashboard', 'analytics', 'visualization'],
        members: [{
          user: user._id,
          role: user.globalRole,
          permissions: ['read', 'write', 'manage', 'delete']
        }]
      }
    ];

    // Limpiar proyectos existentes
    await Project.deleteMany({});

    // Crear proyectos
    for (const projectData of sampleProjects) {
      const project = await Project.create(projectData);
      console.log(`‚úÖ Proyecto creado: ${project.name}`);
    }

    console.log('üéâ Proyectos de ejemplo creados correctamente');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error creando proyectos:', error);
    process.exit(1);
  }
};

if (require.main === module) {
  seedProjects();
}

module.exports = seedProjects;
