// ===================================
// MARIANA GOMEZ - CÓDIGO COMPLETO INTEGRADO
// Módulo: Proyectos (Preparado para Tasks/Comments/IA)
// Integrado perfectamente con Samuel y Maryamm
// ===================================

// ===================================
// src/models/Project.model.js
// ===================================
const mongoose = require('mongoose');

const projectSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100,
    index: true
  },
  description: {
    type: String,
    required: true,
    maxlength: 1000
  },
  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    required: true,
    index: true
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  members: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    role: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Role',
      required: true
    },
    joinedAt: {
      type: Date,
      default: Date.now
    },
    // Permisos específicos para tareas (usado por Maryamm)
    permissions: {
      canCreateTasks: { type: Boolean, default: true },
      canEditTasks: { type: Boolean, default: true },
      canDeleteTasks: { type: Boolean, default: false },
      canAssignTasks: { type: Boolean, default: false }
    }
  }],
  status: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'State',
    required: true,
    index: true
  },
  priority: {
    type: String,
    enum: ['Low', 'Medium', 'High', 'Critical'],
    default: 'Medium',
    index: true
  },
  startDate: {
    type: Date,
    required: true
  },
  endDate: {
    type: Date,
    required: true,
    validate: {
      validator: function(endDate) {
        return endDate > this.startDate;
      },
      message: 'La fecha de fin debe ser posterior a la de inicio'
    }
  },
  estimatedHours: {
    type: Number,
    min: 0,
    default: 0
  },
  actualHours: {
    type: Number,
    min: 0,
    default: 0
  },
  budget: {
    type: Number,
    min: 0,
    default: 0
  },
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: 20
  }],
  // Campos adicionales para integración con tasks y comments
  settings: {
    allowComments: { type: Boolean, default: true },
    allowTaskCreation: { type: Boolean, default: true },
    requireTaskApproval: { type: Boolean, default: false },
    notifyOnTaskComplete: { type: Boolean, default: true },
    aiAssistEnabled: { type: Boolean, default: true }
  },
  // Metadatos para IA (usado por Maryamm)
  aiMetadata: {
    lastAnalysis: { type: Date },
    healthScore: { type: Number, min: 0, max: 100, default: 0 },
    riskLevel: { type: String, enum: ['Low', 'Medium', 'High'], default: 'Low' },
    recommendations: [String]
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true }
});

// Virtual para conteo de tareas (será usado por Maryamm)
projectSchema.virtual('taskCount', {
  ref: 'Task',
  localField: '_id',
  foreignField: 'project',
  count: true
});

// Virtual para conteo de comentarios (será usado por Maryamm)
projectSchema.virtual('commentCount', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'projectid',
  count: true
});

// Virtual para progreso basado en tareas
projectSchema.virtual('progress').get(function() {
  // Este cálculo se actualizará cuando Maryamm implemente las tareas
  return this.aiMetadata?.healthScore || 0;
});

// Virtual para días restantes
projectSchema.virtual('daysRemaining').get(function() {
  const today = new Date();
  const diffTime = this.endDate - today;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual para verificar si está retrasado
projectSchema.virtual('isOverdue').get(function() {
  return this.daysRemaining < 0 && this.status?.name !== 'Completado';
});

// Índices compuestos para mejor rendimiento
projectSchema.index({ owner: 1, isActive: 1 });
projectSchema.index({ 'members.user': 1, isActive: 1 });
projectSchema.index({ category: 1, status: 1 });
projectSchema.index({ priority: 1, endDate: 1 });

// Middleware para actualizar actualHours cuando se calculen desde tareas
projectSchema.methods.updateProgressFromTasks = async function() {
  const Task = mongoose.model('Task');
  
  try {
    const tasks = await Task.find({ project: this._id, isActive: true });
    const completedTasks = tasks.filter(task => task.completedAt);
    const progress = tasks.length > 0 ? Math.round((completedTasks.length / tasks.length) * 100) : 0;
    
    this.aiMetadata.healthScore = progress;
    this.actualHours = tasks.reduce((total, task) => total + (task.actualHours || 0), 0);
    
    return this.save();
  } catch (error) {
    console.error('Error updating progress:', error);
  }
};

module.exports = mongoose.model('Project', projectSchema);

// ===================================
// src/controllers/project.controller.js
// ===================================
const Project = require('../models/Project.model');
const State = require('../models/State.model');
const Category = require('../models/Category.model');
const User = require('../models/User.model');
const Role = require('../models/Role.model');
const { sendResponse, sendError } = require('../utils/response.util');

class ProjectController {
  // Listar proyectos del usuario con estadísticas
  async getProjects(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;
      const { status, priority, category } = req.query;

      // Filtros base
      const filter = {
        isActive: true,
        $or: [
          { owner: req.user.userId },
          { 'members.user': req.user.userId }
        ]
      };

      // Filtros adicionales
      if (status) filter.status = status;
      if (priority) filter.priority = priority;
      if (category) filter.category = category;

      const projects = await Project.find(filter)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name description')
        .populate('status', 'name description')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name')
        .populate('taskCount')
        .populate('commentCount')
        .skip(skip)
        .limit(limit)
        .sort({ updatedAt: -1 });

      const total = await Project.countDocuments(filter);

      // Estadísticas adicionales
      const stats = await this.getProjectStats(req.user.userId);

      sendResponse(res, 200, true, 'Proyectos obtenidos exitosamente', {
        projects,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        },
        stats,
        filters: { status, priority, category }
      });
    } catch (error) {
      console.error('Error obtener proyectos:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Crear proyecto con configuraciones para tasks/comments
  async createProject(req, res) {
    try {
      const {
        name,
        description,
        category,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags,
        settings
      } = req.body;

      // Verificar categoría
      const categoryExists = await Category.findById(category);
      if (!categoryExists || !categoryExists.isActive) {
        return sendError(res, 400, 'Categoría no válida');
      }

      // Estado inicial para proyecto
      let initialState = await State.findOne({
        type: 'Project',
        name: 'Planificación'
      });

      if (!initialState) {
        initialState = await State.create({
          name: 'Planificación',
          type: 'Project',
          description: 'Estado inicial del proyecto'
        });
      }

      // Obtener rol del usuario para el proyecto
      const userRole = await Role.findById(req.user.globalRole._id);

      // Configuraciones por defecto para integración con Maryamm
      const defaultSettings = {
        allowComments: true,
        allowTaskCreation: true,
        requireTaskApproval: userRole?.name === 'Developer',
        notifyOnTaskComplete: true,
        aiAssistEnabled: true,
        ...settings
      };

      // Permisos por defecto basados en rol
      const getPermissionsByRole = (roleName) => {
        switch(roleName) {
          case 'Admin':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: true,
              canAssignTasks: true
            };
          case 'Project Manager':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: true,
              canAssignTasks: true
            };
          case 'Developer':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: false,
              canAssignTasks: false
            };
          default:
            return {
              canCreateTasks: false,
              canEditTasks: false,
              canDeleteTasks: false,
              canAssignTasks: false
            };
        }
      };

      // Crear proyecto
      const project = await Project.create({
        name,
        description,
        category,
        owner: req.user.userId,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags: tags || [],
        status: initialState._id,
        settings: defaultSettings,
        members: [{
          user: req.user.userId,
          role: userRole._id,
          permissions: getPermissionsByRole(userRole?.name)
        }],
        aiMetadata: {
          healthScore: 0,
          riskLevel: 'Low',
          recommendations: []
        }
      });

      // Poblar relaciones
      await project.populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name description' },
        { path: 'status', select: 'name description' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 201, true, 'Proyecto creado exitosamente', { project });
    } catch (error) {
      console.error('Error crear proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Obtener proyecto específico con detalles completos
  async getProject(req, res) {
    try {
      const { id } = req.params;
      const includeStats = req.query.stats === 'true';

      const project = await Project.findById(id)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name description')
        .populate('status', 'name description')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name')
        .populate('taskCount')
        .populate('commentCount');

      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar acceso
      const hasAccess = project.owner._id.toString() === req.user.userId ||
                       project.members.some(member => 
                         member.user._id.toString() === req.user.userId
                       );

      if (!hasAccess) {
        return sendError(res, 403, 'Sin acceso al proyecto');
      }

      let responseData = { project };

      // Incluir estadísticas si se solicitan
      if (includeStats) {
        try {
          // Estas estadísticas se completarán cuando Maryamm implemente Task
          const Task = mongoose.model('Task');
          const Comment = mongoose.model('Comment');
          
          const [tasks, comments] = await Promise.all([
            Task.find({ project: id, isActive: true }).populate('status assignedTo'),
            Comment.find({ projectid: id }).populate('author')
          ]);

          const projectStats = {
            tasks: {
              total: tasks.length,
              completed: tasks.filter(t => t.completedAt).length,
              pending: tasks.filter(t => !t.completedAt).length,
              overdue: tasks.filter(t => t.dueDate < new Date() && !t.completedAt).length
            },
            comments: {
              total: comments.length,
              recent: comments.slice(-5)
            },
            progress: tasks.length > 0 ? 
              Math.round((tasks.filter(t => t.completedAt).length / tasks.length) * 100) : 0
          };

          responseData.stats = projectStats;
        } catch (statError) {
          // Si Task/Comment no existen aún, estadísticas básicas
          responseData.stats = {
            tasks: { total: 0, completed: 0, pending: 0, overdue: 0 },
            comments: { total: 0, recent: [] },
            progress: 0
          };
        }
      }

      sendResponse(res, 200, true, 'Proyecto obtenido exitosamente', responseData);
    } catch (error) {
      console.error('Error obtener proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar proyecto
  async updateProject(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos (owner o PM del proyecto)
      const canEdit = project.owner.toString() === req.user.userId ||
                     project.members.some(member => 
                       member.user.toString() === req.user.userId && 
                       member.role.name === 'Project Manager'
                     );

      if (!canEdit) {
        return sendError(res, 403, 'Sin permisos para editar este proyecto');
      }

      // Validar categoría si se actualiza
      if (updateData.category) {
        const categoryExists = await Category.findById(updateData.category);
        if (!categoryExists || !categoryExists.isActive) {
          return sendError(res, 400, 'Categoría no válida');
        }
      }

      // No permitir cambio de owner por esta ruta
      delete updateData.owner;
      delete updateData.members;

      const updatedProject = await Project.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      ).populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name description' },
        { path: 'status', select: 'name description' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Proyecto actualizado exitosamente', { project: updatedProject });
    } catch (error) {
      console.error('Error actualizar proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Eliminar proyecto (soft delete)
  async deleteProject(req, res) {
    try {
      const { id } = req.params;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner o Admin pueden eliminar
      const canDelete = project.owner.toString() === req.user.userId ||
                       req.user.role === 'Admin';

      if (!canDelete) {
        return sendError(res, 403, 'Sin permisos para eliminar este proyecto');
      }

      await Project.findByIdAndUpdate(id, { isActive: false });

      sendResponse(res, 200, true, 'Proyecto eliminado exitosamente');
    } catch (error) {
      console.error('Error eliminar proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Agregar miembro al proyecto con permisos específicos
  async addMember(req, res) {
    try {
      const { id } = req.params;
      const { user, role, permissions } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede agregar miembros
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede agregar miembros');
      }

      // Verificar que el usuario existe
      const userExists = await User.findById(user);
      if (!userExists || !userExists.isActive) {
        return sendError(res, 400, 'Usuario no válido');
      }

      // Verificar que el rol existe
      const roleExists = await Role.findById(role);
      if (!roleExists || !roleExists.isActive) {
        return sendError(res, 400, 'Rol no válido');
      }

      // Verificar que no sea ya miembro
      const isAlreadyMember = project.members.some(
        member => member.user.toString() === user
      );

      if (isAlreadyMember) {
        return sendError(res, 400, 'El usuario ya es miembro del proyecto');
      }

      // Permisos por defecto basados en rol si no se especifican
      const defaultPermissions = permissions || this.getPermissionsByRole(roleExists.name);

      // Agregar miembro
      project.members.push({ 
        user, 
        role,
        permissions: defaultPermissions
      });
      await project.save();

      await project.populate([
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Miembro agregado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          members: project.members
        }
      });
    } catch (error) {
      console.error('Error agregar miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Remover miembro del proyecto
  async removeMember(req, res) {
    try {
      const { id, userId } = req.params;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede remover miembros
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede remover miembros');
      }

      // No se puede remover al owner
      if (userId === project.owner.toString()) {
        return sendError(res, 400, 'No se puede remover al propietario del proyecto');
      }

      // Verificar que es miembro
      const memberIndex = project.members.findIndex(
        member => member.user.toString() === userId
      );

      if (memberIndex === -1) {
        return sendError(res, 400, 'El usuario no es miembro del proyecto');
      }

      // Remover miembro
      project.members.splice(memberIndex, 1);
      await project.save();

      sendResponse(res, 200, true, 'Miembro removido exitosamente');
    } catch (error) {
      console.error('Error remover miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Cambiar estado del proyecto
  async changeStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos (owner o PM del proyecto)
      const canChange = project.owner.toString() === req.user.userId ||
                       project.members.some(member => 
                         member.user.toString() === req.user.userId && 
                         member.role.name === 'Project Manager'
                       );

      if (!canChange) {
        return sendError(res, 403, 'Sin permisos para cambiar el estado');
      }

      // Verificar estado válido
      const newStatus = await State.findById(status);
      if (!newStatus || !newStatus.isActive || newStatus.type !== 'Project') {
        return sendError(res, 400, 'Estado no válido para proyectos');
      }

      project.status = status;
      
      // Actualizar progreso si el proyecto se completa
      if (newStatus.name === 'Completado') {
        project.aiMetadata.healthScore = 100;
      }

      await project.save();
      await project.populate('status', 'name description');

      sendResponse(res, 200, true, 'Estado actualizado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          status: project.status,
          aiMetadata: project.aiMetadata
        }
      });
    } catch (error) {
      console.error('Error cambiar estado:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar configuraciones del proyecto
  async updateSettings(req, res) {
    try {
      const { id } = req.params;
      const { settings } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede cambiar configuraciones
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede cambiar configuraciones');
      }

      project.settings = { ...project.settings, ...settings };
      await project.save();

      sendResponse(res, 200, true, 'Configuraciones actualizadas', {
        settings: project.settings
      });
    } catch (error) {
      console.error('Error actualizar configuraciones:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar permisos de miembro
  async updateMemberPermissions(req, res) {
    try {
      const { id, userId } = req.params;
      const { permissions } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede cambiar permisos
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede cambiar permisos');
      }

      const memberIndex = project.members.findIndex(
        member => member.user.toString() === userId
      );

      if (memberIndex === -1) {
        return sendError(res, 400, 'Usuario no es miembro del proyecto');
      }

      project.members[memberIndex].permissions = {
        ...project.members[memberIndex].permissions,
        ...permissions
      };

      await project.save();

      sendResponse(res, 200, true, 'Permisos actualizados exitosamente', {
        member: project.members[memberIndex]
      });
    } catch (error) {
      console.error('Error actualizar permisos:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Helper: Obtener estadísticas del usuario
  async getProjectStats(userId) {
    try {
      const totalProjects = await Project.countDocuments({
        $or: [{ owner: userId }, { 'members.user': userId }],
        isActive: true
      });

      const ownedProjects = await Project.countDocuments({
        owner: userId,
        isActive: true
      });

      const memberProjects = totalProjects - ownedProjects;

      const overdueProjects = await Project.countDocuments({
        $or: [{ owner: userId }, { 'members.user': userId }],
        isActive: true,
        endDate: { $lt: new Date() }
      });

      return {
        total: totalProjects,
        owned: ownedProjects,
        member: memberProjects,
        overdue: overdueProjects
      };
    } catch (error) {
      console.error('Error obteniendo estadísticas:', error);
      return { total: 0, owned: 0, member: 0, overdue: 0 };
    }
  }

  // Helper: Permisos por rol
  getPermissionsByRole(roleName) {
    switch(roleName) {
      case 'Admin':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: true,
          canAssignTasks: true
        };
      case 'Project Manager':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: true,
          canAssignTasks: true
        };
      case 'Developer':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: false,
          canAssignTasks: false
        };
      default:
        return {
          canCreateTasks: false,
          canEditTasks: false,
          canDeleteTasks: false,
          canAssignTasks: false
        };
    }
  }
}

module.exports = new ProjectController();

// ===================================
// src/routes/project.routes.js
// ===================================
const express = require('express');
const router = express.Router();
const projectController = require('../controllers/project.controller');
const { 
  validateProject, 
  validateMember, 
  validateStatus,
  validateSettings,
  validatePermissions
} = require('../validators/project.validator');
const { authenticate } = require('../middlewares/auth.middleware');
const { authorize } = require('../middlewares/role.middleware');
const { handleValidation } = require('../middlewares/validation.middleware');

// Todas las rutas requieren autenticación
router.use(authenticate);

// Rutas principales
router.get('/', projectController.getProjects);
router.post('/', 
  authorize(['Admin', 'Project Manager']), 
  validateProject, 
  handleValidation, 
  projectController.createProject
);
router.get('/:id', projectController.getProject);
router.put('/:id', 
  validateProject, 
  handleValidation, 
  projectController.updateProject
);
router.delete('/:id', 
  authorize(['Admin']), 
  projectController.deleteProject
);

// Gestión de miembros
router.post('/:id/members', 
  validateMember, 
  handleValidation, 
  projectController.addMember
);
router.delete('/:id/members/:userId', 
  projectController.removeMember
);
router.put('/:id/members/:userId/permissions',
  validatePermissions,
  handleValidation,
  projectController.updateMemberPermissions
);

// Estado y configuraciones
router.put('/:id/status', 
  validateStatus, 
  handleValidation, 
  projectController.changeStatus
);
router.put('/:id/settings',
  validateSettings,
  handleValidation,
  projectController.updateSettings
);

module.exports = router;

// ===================================
// src/validators/project.validator.js
// ===================================
const { body, param } = require('express-validator');

const validateProject = [
  body('name')
    .trim()
    .isLength({ min: 3, max: 100 })
    .withMessage('Nombre debe tener entre 3 y 100 caracteres'),

  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Descripción debe tener entre 10 y 1000 caracteres'),

  body('category')
    .isMongoId()
    .withMessage('ID de categoría inválido'),

  body('startDate')
    .isISO8601()
    .withMessage('Fecha de inicio inválida'),

  body('endDate')
    .isISO8601()
    .withMessage('Fecha de fin inválida')
    .custom((endDate, { req }) => {
      if (new Date(endDate) <= new Date(req.body.startDate)) {
        throw new Error('Fecha de fin debe ser posterior al inicio');
      }
      return true;
    }),

  body('estimatedHours')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Horas estimadas deben ser positivas'),

  body('budget')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Presupuesto debe ser positivo'),

  body('priority')
    .optional()
    .isIn(['Low', 'Medium', 'High', 'Critical'])
    .withMessage('Prioridad inválida'),

  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags deben ser un array'),

  body('tags.*')
    .optional()
    .trim()
    .isLength({ min: 1, max: 20 })
    .withMessage('Cada tag debe tener entre 1 y 20 caracteres'),

  body('settings')
    .optional()
    .isObject()
    .withMessage('Settings debe ser un objeto'),

  body('settings.allowComments')
    .optional()
    .isBoolean()
    .withMessage('allowComments debe ser booleano'),

  body('settings.allowTaskCreation')
    .optional()
    .isBoolean()
    .withMessage('allowTaskCreation debe ser booleano'),

  body('settings.requireTaskApproval')
    .optional()
    .isBoolean()
    .withMessage('requireTaskApproval debe ser booleano'),

  body('settings.notifyOnTaskComplete')
    .optional()
    .isBoolean()
    .withMessage('notifyOnTaskComplete debe ser booleano'),

  body('settings.aiAssistEnabled')
    .optional()
    .isBoolean()
    .withMessage('aiAssistEnabled debe ser booleano')
];

const validateMember = [
  body('user')
    .isMongoId()
    .withMessage('ID de usuario inválido'),

  body('role')
    .isMongoId()
    .withMessage('ID de rol inválido'),

  body('permissions')
    .optional()
    .isObject()
    .withMessage('Permisos debe ser un objeto'),

  body('permissions.canCreateTasks')
    .optional()
    .isBoolean()
    .withMessage('canCreateTasks debe ser booleano'),

  body('permissions.canEditTasks')
    .optional()
    .isBoolean()
    .withMessage('canEditTasks debe ser booleano'),

  body('permissions.canDeleteTasks')
    .optional()
    .isBoolean()
    .withMessage('canDeleteTasks debe ser booleano'),

  body('permissions.canAssignTasks')
    .optional()
    .isBoolean()
    .withMessage('canAssignTasks debe ser booleano')
];

const validateStatus = [
  body('status')
    .isMongoId()
    .withMessage('ID de estado inválido')
];

const validateSettings = [
  body('settings')
    .isObject()
    .withMessage('Settings es requerido y debe ser un objeto'),

  body('settings.allowComments')
    .optional()
    .isBoolean()
    .withMessage('allowComments debe ser booleano'),

  body('settings.allowTaskCreation')
    .optional()
    .isBoolean()
    .withMessage('allowTaskCreation debe ser booleano'),

  body('settings.requireTaskApproval')
    .optional()
    .isBoolean()
    .withMessage('requireTaskApproval debe ser booleano'),

  body('settings.notifyOnTaskComplete')
    .optional()
    .isBoolean()
    .withMessage('notifyOnTaskComplete debe ser booleano'),

  body('settings.aiAssistEnabled')
    .optional()
    .isBoolean()
    .withMessage('aiAssistEnabled debe ser booleano')
];

const validatePermissions = [
  body('permissions')
    .isObject()
    .withMessage('Permisos es requerido y debe ser un objeto'),

  body('permissions.canCreateTasks')
    .optional()
    .isBoolean()
    .withMessage('canCreateTasks debe ser booleano'),

  body('permissions.canEditTasks')
    .optional()
    .isBoolean()
    .withMessage('canEditTasks debe ser booleano'),

  body('permissions.canDeleteTasks')
    .optional()
    .isBoolean()
    .withMessage('canDeleteTasks debe ser booleano'),

  body('permissions.canAssignTasks')
    .optional()
    .isBoolean()
    .withMessage('canAssignTasks debe ser booleano')
];

module.exports = {
  validateProject,
  validateMember,
  validateStatus,
  validateSettings,
  validatePermissions
};

// ===================================
// tests/project.test.js
// ===================================
const request = require('supertest');
const app = require('../server');
const Project = require('../src/models/Project.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const User = require('../src/models/User.model');
const Role = require('../src/models/Role.model');

describe('Project Endpoints', () => {
  let authToken;
  let testUser;
  let testCategory;
  let testState;
  let pmRole;

  beforeAll(async () => {
    // Crear rol PM
    pmRole = await Role.create({
      name: 'Project Manager',
      description: 'Gestor de proyectos'
    });

    // Crear usuario
    testUser = await User.create({
      firstName: 'Test',
      lastName: 'PM',
      email: 'pm@test.com',
      password: 'password123',
      globalRole: pmRole._id,
      isEmailVerified: true
    });

    // Crear categoría
    testCategory = await Category.create({
      name: 'Test Category',
      description: 'Categoría de prueba',
      createdBy: testUser._id
    });

    // Crear estado
    testState = await State.create({
      name: 'Planificación',
      type: 'Project',
      description: 'Estado inicial'
    });

    // Login
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'pm@test.com',
        password: 'password123'
      });

    authToken = loginResponse.body.data.token;
  });

  beforeEach(async () => {
    await Project.deleteMany({});
  });

  describe('POST /api/projects', () => {
    test('Should create a new project with default settings', async () => {
      const projectData = {
        name: 'Test Project',
        description: 'This is a test project description with enough characters',
        category: testCategory._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        estimatedHours: 100,
        budget: 5000,
        priority: 'High',
        tags: ['test', 'demo']
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(projectData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.project.name).toBe(projectData.name);
      expect(response.body.data.project.settings.allowComments).toBe(true);
      expect(response.body.data.project.settings.aiAssistEnabled).toBe(true);
    });

    test('Should create project with custom settings', async () => {
      const projectData = {
        name: 'Custom Settings Project',
        description: 'Project with custom settings for testing',
        category: testCategory._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        settings: {
          allowComments: false,
          requireTaskApproval: true,
          aiAssistEnabled: false
        }
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(projectData);

      expect(response.status).toBe(201);
      expect(response.body.data.project.settings.allowComments).toBe(false);
      expect(response.body.data.project.settings.requireTaskApproval).toBe(true);
      expect(response.body.data.project.settings.aiAssistEnabled).toBe(false);
    });
  });

  describe('GET /api/projects', () => {
    beforeEach(async () => {
      await Project.create({
        name: 'Test Project',
        description: 'Test project description for listing',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }]
      });
    });

    test('Should get user projects with stats', async () => {
      const response = await request(app)
        .get('/api/projects')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.projects).toHaveLength(1);
      expect(response.body.data.stats).toBeDefined();
      expect(response.body.data.stats.total).toBe(1);
    });
  });

  describe('POST /api/projects/:id/members', () => {
    let testProject;
    let newUser;
    let devRole;

    beforeEach(async () => {
      // Crear rol developer
      devRole = await Role.findOne({ name: 'Developer' }) ||
                await Role.create({ name: 'Developer', description: 'Developer role' });

      // Crear nuevo usuario
      newUser = await User.create({
        firstName: 'New',
        lastName: 'Developer',
        email: 'dev@test.com',
        password: 'password123',
        globalRole: devRole._id
      });

      // Crear proyecto
      testProject = await Project.create({
        name: 'Test Project',
        description: 'Test description for member testing',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }]
      });
    });

    test('Should add member with custom permissions', async () => {
      const memberData = {
        user: newUser._id,
        role: devRole._id,
        permissions: {
          canCreateTasks: true,
          canEditTasks: false,
          canDeleteTasks: false,
          canAssignTasks: false
        }
      };

      const response = await request(app)
        .post(`/api/projects/${testProject._id}/members`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(memberData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.project.members).toHaveLength(2);
    });
  });

  describe('PUT /api/projects/:id/settings', () => {
    let testProject;

    beforeEach(async () => {
      testProject = await Project.create({
        name: 'Settings Test Project',
        description: 'Project for testing settings updates',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id
        }]
      });
    });

    test('Should update project settings', async () => {
      const newSettings = {
        settings: {
          allowComments: false,
          requireTaskApproval: true,
          aiAssistEnabled: false
        }
      };

      const response = await request(app)
        .put(`/api/projects/${testProject._id}/settings`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(newSettings);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.settings.allowComments).toBe(false);
      expect(response.body.data.settings.requireTaskApproval).toBe(true);
    });
  });
});

// ===================================
// scripts/seed-projects.js
// ===================================
const mongoose = require('mongoose');
const Project = require('../src/models/Project.model');
const User = require('../src/models/User.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const Role = require('../src/models/Role.model');
require('dotenv').config();

const seedProjects = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Conectado a MongoDB para seed de proyectos');

    // Obtener datos necesarios
    const adminUser = await User.findOne({ email: 'admin@test.com' });
    const webCategory = await Category.findOne({ name: 'Web Development' }) ||
                       await Category.create({
                         name: 'Web Development',
                         description: 'Desarrollo de aplicaciones web',
                         createdBy: adminUser._id
                       });

    const planningState = await State.findOne({ name: 'Planificación', type: 'Project' });
    const progressState = await State.findOne({ name: 'En Progreso', type: 'Project' });
    const pmRole = await Role.findOne({ name: 'Project Manager' });
    const devRole = await Role.findOne({ name: 'Developer' });

    const sampleProjects = [
      {
        name: 'E-commerce Platform',
        description: 'Desarrollo de plataforma de comercio electrónico con React y Node.js. Incluye carrito de compras, pagos en línea, gestión de inventario y panel de administración.',
        category: webCategory._id,
        owner: adminUser._id,
        status: progressState._id,
        priority: 'High',
        startDate: new Date('2024-01-15'),
        endDate: new Date('2024-06-30'),
        estimatedHours: 500,
        budget: 25000,
        tags: ['react', 'nodejs', 'ecommerce', 'stripe'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: false,
          notifyOnTaskComplete: true,
          aiAssistEnabled: true
        },
        aiMetadata: {
          healthScore: 75,
          riskLevel: 'Medium',
          recommendations: [
            'Revisar cronograma de desarrollo',
            'Aumentar cobertura de testing',
            'Implementar CI/CD pipeline'
          ]
        }
      },
      {
        name: 'Mobile Banking App',
        description: 'Aplicación móvil para banca digital con autenticación biométrica, transferencias, pagos y gestión de cuentas.',
        category: webCategory._id,
        owner: adminUser._id,
        status: planningState._id,
        priority: 'Critical',
        startDate: new Date('2024-03-01'),
        endDate: new Date('2024-12-31'),
        estimatedHours: 800,
        budget: 50000,
        tags: ['mobile', 'banking', 'security', 'flutter'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: true,
          notifyOnTaskComplete: true,
          aiAssistEnabled: true
        },
        aiMetadata: {
          healthScore: 20,
          riskLevel: 'Low',
          recommendations: [
            'Definir arquitectura de seguridad',
            'Seleccionar stack tecnológico',
            'Crear wireframes y prototipos'
          ]
        }
      },
      {
        name: 'Company Intranet',
        description: 'Sistema interno para gestión de empleados, documentos, comunicación interna y recursos humanos.',
        category: webCategory._id,
        owner: adminUser._id,
        status: progressState._id,
        priority: 'Medium',
        startDate: new Date('2024-02-01'),
        endDate: new Date('2024-08-15'),
        estimatedHours: 300,
        budget: 15000,
        tags: ['intranet', 'hr', 'internal', 'vue'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: false,
          notifyOnTaskComplete: false,
          aiAssistEnabled: false
        },
        aiMetadata: {
          healthScore: 60,
          riskLevel: 'Low',
          recommendations: [
            'Integrar con sistema de RRHH existente',
            'Mejorar UX del dashboard'
          ]
        }
      }
    ];

    // Limpiar proyectos existentes
    await Project.deleteMany({});

    // Crear proyectos de ejemplo
    for (const projectData of sampleProjects) {
      const project = await Project.create(projectData);
      console.log(`✅ Proyecto creado: ${project.name}`);
    }

    console.log('🎉 Seed de proyectos completado exitosamente');
    process.exit(0);
  } catch (error) {
    console.error('❌ Error en seed de proyectos:', error);
    process.exit(1);
  }
};

if (require.main === module) {
  seedProjects();
}

module.exports = seedProjects;

// ===================================
// Actualización necesaria en server.js
// ===================================

/*
AGREGAR ESTA LÍNEA EN server.js DESPUÉS DE LAS RUTAS EXISTENTES:

// Rutas existentes...
app.use('/api/auth', require('./src/routes/auth.routes'));
app.use('/api/users', require('./src/routes/user.routes'));
app.use('/api/roles', require('./src/routes/role.routes'));
app.use('/api/categories', require('./src/routes/category.routes'));
app.use('/api/states', require('./src/routes/state.routes'));
app.use('/api/upload', require('./src/routes/upload.routes'));

// ✅ NUEVA RUTA DE MARIANA:
app.use('/api/projects', require('./src/routes/project.routes'));

// Las rutas de Maryamm se agregarán después:
// app.use('/api/tasks', require('./src/routes/task.routes'));
// app.use('/api/comments', require('./src/routes/comment.routes'));
// app.use('/api/ai', require('./src/routes/ai.routes'));
*/

// ===================================
// DOCUMENTACIÓN DE INTEGRACIÓN
// ===================================

/*
🔗 INTEGRACIÓN CON MARYAMM:

1. CAMPOS PREPARADOS PARA TASKS:
   - members[].permissions.canCreateTasks
   - members[].permissions.canEditTasks
   - members[].permissions.canDeleteTasks
   - members[].permissions.canAssignTasks
   - settings.allowTaskCreation
   - settings.requireTaskApproval
   - settings.notifyOnTaskComplete

2. CAMPOS PREPARADOS PARA COMMENTS:
   - settings.allowComments

3. CAMPOS PREPARADOS PARA IA:
   - settings.aiAssistEnabled
   - aiMetadata.healthScore
   - aiMetadata.riskLevel
   - aiMetadata.recommendations
   - aiMetadata.lastAnalysis

4. VIRTUALS DISPONIBLES:
   - taskCount (conteo de tareas)
   - commentCount (conteo de comentarios)
   - progress (progreso basado en tareas)
   - isOverdue (proyecto retrasado)

5. MÉTODOS HELPER:
   - updateProgressFromTasks() (actualizar progreso desde tareas)
   - getPermissionsByRole() (permisos por rol)

6. ENDPOINTS LISTOS:
   - PUT /api/projects/:id/settings (configurar IA/tasks/comments)
   - PUT /api/projects/:id/members/:userId/permissions (permisos de tareas)

7. CAMPOS POPULADOS EN RELACIONES:
   - Virtual taskCount y commentCount automáticamente populados
   - Members con permisos específicos para cada usuario

🚀 ¡LISTO PARA INTEGRACIÓN PERFECTA CON MARYAMM!
*/