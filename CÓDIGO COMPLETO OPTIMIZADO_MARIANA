// ===================================
// MARIANA GOMEZ - C√ìDIGO COMPLETO INTEGRADO
// M√≥dulo: Proyectos (Preparado para Tasks/Comments/IA)
// Integrado perfectamente con Samuel y Maryamm
// ===================================

// ===================================
// src/models/Project.model.js
// ===================================
const mongoose = require('mongoose');

const projectSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100,
    index: true
  },
  description: {
    type: String,
    required: true,
    maxlength: 1000
  },
  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    required: true,
    index: true
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  members: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    role: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Role',
      required: true
    },
    joinedAt: {
      type: Date,
      default: Date.now
    },
    // Permisos espec√≠ficos para tareas (usado por Maryamm)
    permissions: {
      canCreateTasks: { type: Boolean, default: true },
      canEditTasks: { type: Boolean, default: true },
      canDeleteTasks: { type: Boolean, default: false },
      canAssignTasks: { type: Boolean, default: false }
    }
  }],
  status: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'State',
    required: true,
    index: true
  },
  priority: {
    type: String,
    enum: ['Low', 'Medium', 'High', 'Critical'],
    default: 'Medium',
    index: true
  },
  startDate: {
    type: Date,
    required: true
  },
  endDate: {
    type: Date,
    required: true,
    validate: {
      validator: function(endDate) {
        return endDate > this.startDate;
      },
      message: 'La fecha de fin debe ser posterior a la de inicio'
    }
  },
  estimatedHours: {
    type: Number,
    min: 0,
    default: 0
  },
  actualHours: {
    type: Number,
    min: 0,
    default: 0
  },
  budget: {
    type: Number,
    min: 0,
    default: 0
  },
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: 20
  }],
  // Campos adicionales para integraci√≥n con tasks y comments
  settings: {
    allowComments: { type: Boolean, default: true },
    allowTaskCreation: { type: Boolean, default: true },
    requireTaskApproval: { type: Boolean, default: false },
    notifyOnTaskComplete: { type: Boolean, default: true },
    aiAssistEnabled: { type: Boolean, default: true }
  },
  // Metadatos para IA (usado por Maryamm)
  aiMetadata: {
    lastAnalysis: { type: Date },
    healthScore: { type: Number, min: 0, max: 100, default: 0 },
    riskLevel: { type: String, enum: ['Low', 'Medium', 'High'], default: 'Low' },
    recommendations: [String]
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true }
});

// Virtual para conteo de tareas (ser√° usado por Maryamm)
projectSchema.virtual('taskCount', {
  ref: 'Task',
  localField: '_id',
  foreignField: 'project',
  count: true
});

// Virtual para conteo de comentarios (ser√° usado por Maryamm)
projectSchema.virtual('commentCount', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'projectid',
  count: true
});

// Virtual para progreso basado en tareas
projectSchema.virtual('progress').get(function() {
  // Este c√°lculo se actualizar√° cuando Maryamm implemente las tareas
  return this.aiMetadata?.healthScore || 0;
});

// Virtual para d√≠as restantes
projectSchema.virtual('daysRemaining').get(function() {
  const today = new Date();
  const diffTime = this.endDate - today;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual para verificar si est√° retrasado
projectSchema.virtual('isOverdue').get(function() {
  return this.daysRemaining < 0 && this.status?.name !== 'Completado';
});

// √çndices compuestos para mejor rendimiento
projectSchema.index({ owner: 1, isActive: 1 });
projectSchema.index({ 'members.user': 1, isActive: 1 });
projectSchema.index({ category: 1, status: 1 });
projectSchema.index({ priority: 1, endDate: 1 });

// Middleware para actualizar actualHours cuando se calculen desde tareas
projectSchema.methods.updateProgressFromTasks = async function() {
  const Task = mongoose.model('Task');
  
  try {
    const tasks = await Task.find({ project: this._id, isActive: true });
    const completedTasks = tasks.filter(task => task.completedAt);
    const progress = tasks.length > 0 ? Math.round((completedTasks.length / tasks.length) * 100) : 0;
    
    this.aiMetadata.healthScore = progress;
    this.actualHours = tasks.reduce((total, task) => total + (task.actualHours || 0), 0);
    
    return this.save();
  } catch (error) {
    console.error('Error updating progress:', error);
  }
};

module.exports = mongoose.model('Project', projectSchema);

// ===================================
// src/controllers/project.controller.js
// ===================================
const Project = require('../models/Project.model');
const State = require('../models/State.model');
const Category = require('../models/Category.model');
const User = require('../models/User.model');
const Role = require('../models/Role.model');
const { sendResponse, sendError } = require('../utils/response.util');

class ProjectController {
  // Listar proyectos del usuario con estad√≠sticas
  async getProjects(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;
      const { status, priority, category } = req.query;

      // Filtros base
      const filter = {
        isActive: true,
        $or: [
          { owner: req.user.userId },
          { 'members.user': req.user.userId }
        ]
      };

      // Filtros adicionales
      if (status) filter.status = status;
      if (priority) filter.priority = priority;
      if (category) filter.category = category;

      const projects = await Project.find(filter)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name description')
        .populate('status', 'name description')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name')
        .populate('taskCount')
        .populate('commentCount')
        .skip(skip)
        .limit(limit)
        .sort({ updatedAt: -1 });

      const total = await Project.countDocuments(filter);

      // Estad√≠sticas adicionales
      const stats = await this.getProjectStats(req.user.userId);

      sendResponse(res, 200, true, 'Proyectos obtenidos exitosamente', {
        projects,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        },
        stats,
        filters: { status, priority, category }
      });
    } catch (error) {
      console.error('Error obtener proyectos:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Crear proyecto con configuraciones para tasks/comments
  async createProject(req, res) {
    try {
      const {
        name,
        description,
        category,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags,
        settings
      } = req.body;

      // Verificar categor√≠a
      const categoryExists = await Category.findById(category);
      if (!categoryExists || !categoryExists.isActive) {
        return sendError(res, 400, 'Categor√≠a no v√°lida');
      }

      // Estado inicial para proyecto
      let initialState = await State.findOne({
        type: 'Project',
        name: 'Planificaci√≥n'
      });

      if (!initialState) {
        initialState = await State.create({
          name: 'Planificaci√≥n',
          type: 'Project',
          description: 'Estado inicial del proyecto'
        });
      }

      // Obtener rol del usuario para el proyecto
      const userRole = await Role.findById(req.user.globalRole._id);

      // Configuraciones por defecto para integraci√≥n con Maryamm
      const defaultSettings = {
        allowComments: true,
        allowTaskCreation: true,
        requireTaskApproval: userRole?.name === 'Developer',
        notifyOnTaskComplete: true,
        aiAssistEnabled: true,
        ...settings
      };

      // Permisos por defecto basados en rol
      const getPermissionsByRole = (roleName) => {
        switch(roleName) {
          case 'Admin':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: true,
              canAssignTasks: true
            };
          case 'Project Manager':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: true,
              canAssignTasks: true
            };
          case 'Developer':
            return {
              canCreateTasks: true,
              canEditTasks: true,
              canDeleteTasks: false,
              canAssignTasks: false
            };
          default:
            return {
              canCreateTasks: false,
              canEditTasks: false,
              canDeleteTasks: false,
              canAssignTasks: false
            };
        }
      };

      // Crear proyecto
      const project = await Project.create({
        name,
        description,
        category,
        owner: req.user.userId,
        startDate,
        endDate,
        estimatedHours,
        budget,
        priority,
        tags: tags || [],
        status: initialState._id,
        settings: defaultSettings,
        members: [{
          user: req.user.userId,
          role: userRole._id,
          permissions: getPermissionsByRole(userRole?.name)
        }],
        aiMetadata: {
          healthScore: 0,
          riskLevel: 'Low',
          recommendations: []
        }
      });

      // Poblar relaciones
      await project.populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name description' },
        { path: 'status', select: 'name description' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 201, true, 'Proyecto creado exitosamente', { project });
    } catch (error) {
      console.error('Error crear proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Obtener proyecto espec√≠fico con detalles completos
  async getProject(req, res) {
    try {
      const { id } = req.params;
      const includeStats = req.query.stats === 'true';

      const project = await Project.findById(id)
        .populate('owner', 'firstName lastName email avatar')
        .populate('category', 'name description')
        .populate('status', 'name description')
        .populate('members.user', 'firstName lastName email avatar')
        .populate('members.role', 'name')
        .populate('taskCount')
        .populate('commentCount');

      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar acceso
      const hasAccess = project.owner._id.toString() === req.user.userId ||
                       project.members.some(member => 
                         member.user._id.toString() === req.user.userId
                       );

      if (!hasAccess) {
        return sendError(res, 403, 'Sin acceso al proyecto');
      }

      let responseData = { project };

      // Incluir estad√≠sticas si se solicitan
      if (includeStats) {
        try {
          // Estas estad√≠sticas se completar√°n cuando Maryamm implemente Task
          const Task = mongoose.model('Task');
          const Comment = mongoose.model('Comment');
          
          const [tasks, comments] = await Promise.all([
            Task.find({ project: id, isActive: true }).populate('status assignedTo'),
            Comment.find({ projectid: id }).populate('author')
          ]);

          const projectStats = {
            tasks: {
              total: tasks.length,
              completed: tasks.filter(t => t.completedAt).length,
              pending: tasks.filter(t => !t.completedAt).length,
              overdue: tasks.filter(t => t.dueDate < new Date() && !t.completedAt).length
            },
            comments: {
              total: comments.length,
              recent: comments.slice(-5)
            },
            progress: tasks.length > 0 ? 
              Math.round((tasks.filter(t => t.completedAt).length / tasks.length) * 100) : 0
          };

          responseData.stats = projectStats;
        } catch (statError) {
          // Si Task/Comment no existen a√∫n, estad√≠sticas b√°sicas
          responseData.stats = {
            tasks: { total: 0, completed: 0, pending: 0, overdue: 0 },
            comments: { total: 0, recent: [] },
            progress: 0
          };
        }
      }

      sendResponse(res, 200, true, 'Proyecto obtenido exitosamente', responseData);
    } catch (error) {
      console.error('Error obtener proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar proyecto
  async updateProject(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos (owner o PM del proyecto)
      const canEdit = project.owner.toString() === req.user.userId ||
                     project.members.some(member => 
                       member.user.toString() === req.user.userId && 
                       member.role.name === 'Project Manager'
                     );

      if (!canEdit) {
        return sendError(res, 403, 'Sin permisos para editar este proyecto');
      }

      // Validar categor√≠a si se actualiza
      if (updateData.category) {
        const categoryExists = await Category.findById(updateData.category);
        if (!categoryExists || !categoryExists.isActive) {
          return sendError(res, 400, 'Categor√≠a no v√°lida');
        }
      }

      // No permitir cambio de owner por esta ruta
      delete updateData.owner;
      delete updateData.members;

      const updatedProject = await Project.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      ).populate([
        { path: 'owner', select: 'firstName lastName email avatar' },
        { path: 'category', select: 'name description' },
        { path: 'status', select: 'name description' },
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Proyecto actualizado exitosamente', { project: updatedProject });
    } catch (error) {
      console.error('Error actualizar proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Eliminar proyecto (soft delete)
  async deleteProject(req, res) {
    try {
      const { id } = req.params;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner o Admin pueden eliminar
      const canDelete = project.owner.toString() === req.user.userId ||
                       req.user.role === 'Admin';

      if (!canDelete) {
        return sendError(res, 403, 'Sin permisos para eliminar este proyecto');
      }

      await Project.findByIdAndUpdate(id, { isActive: false });

      sendResponse(res, 200, true, 'Proyecto eliminado exitosamente');
    } catch (error) {
      console.error('Error eliminar proyecto:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Agregar miembro al proyecto con permisos espec√≠ficos
  async addMember(req, res) {
    try {
      const { id } = req.params;
      const { user, role, permissions } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede agregar miembros
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede agregar miembros');
      }

      // Verificar que el usuario existe
      const userExists = await User.findById(user);
      if (!userExists || !userExists.isActive) {
        return sendError(res, 400, 'Usuario no v√°lido');
      }

      // Verificar que el rol existe
      const roleExists = await Role.findById(role);
      if (!roleExists || !roleExists.isActive) {
        return sendError(res, 400, 'Rol no v√°lido');
      }

      // Verificar que no sea ya miembro
      const isAlreadyMember = project.members.some(
        member => member.user.toString() === user
      );

      if (isAlreadyMember) {
        return sendError(res, 400, 'El usuario ya es miembro del proyecto');
      }

      // Permisos por defecto basados en rol si no se especifican
      const defaultPermissions = permissions || this.getPermissionsByRole(roleExists.name);

      // Agregar miembro
      project.members.push({ 
        user, 
        role,
        permissions: defaultPermissions
      });
      await project.save();

      await project.populate([
        { path: 'members.user', select: 'firstName lastName email avatar' },
        { path: 'members.role', select: 'name' }
      ]);

      sendResponse(res, 200, true, 'Miembro agregado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          members: project.members
        }
      });
    } catch (error) {
      console.error('Error agregar miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Remover miembro del proyecto
  async removeMember(req, res) {
    try {
      const { id, userId } = req.params;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede remover miembros
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede remover miembros');
      }

      // No se puede remover al owner
      if (userId === project.owner.toString()) {
        return sendError(res, 400, 'No se puede remover al propietario del proyecto');
      }

      // Verificar que es miembro
      const memberIndex = project.members.findIndex(
        member => member.user.toString() === userId
      );

      if (memberIndex === -1) {
        return sendError(res, 400, 'El usuario no es miembro del proyecto');
      }

      // Remover miembro
      project.members.splice(memberIndex, 1);
      await project.save();

      sendResponse(res, 200, true, 'Miembro removido exitosamente');
    } catch (error) {
      console.error('Error remover miembro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Cambiar estado del proyecto
  async changeStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Verificar permisos (owner o PM del proyecto)
      const canChange = project.owner.toString() === req.user.userId ||
                       project.members.some(member => 
                         member.user.toString() === req.user.userId && 
                         member.role.name === 'Project Manager'
                       );

      if (!canChange) {
        return sendError(res, 403, 'Sin permisos para cambiar el estado');
      }

      // Verificar estado v√°lido
      const newStatus = await State.findById(status);
      if (!newStatus || !newStatus.isActive || newStatus.type !== 'Project') {
        return sendError(res, 400, 'Estado no v√°lido para proyectos');
      }

      project.status = status;
      
      // Actualizar progreso si el proyecto se completa
      if (newStatus.name === 'Completado') {
        project.aiMetadata.healthScore = 100;
      }

      await project.save();
      await project.populate('status', 'name description');

      sendResponse(res, 200, true, 'Estado actualizado exitosamente', {
        project: {
          _id: project._id,
          name: project.name,
          status: project.status,
          aiMetadata: project.aiMetadata
        }
      });
    } catch (error) {
      console.error('Error cambiar estado:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar configuraciones del proyecto
  async updateSettings(req, res) {
    try {
      const { id } = req.params;
      const { settings } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede cambiar configuraciones
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede cambiar configuraciones');
      }

      project.settings = { ...project.settings, ...settings };
      await project.save();

      sendResponse(res, 200, true, 'Configuraciones actualizadas', {
        settings: project.settings
      });
    } catch (error) {
      console.error('Error actualizar configuraciones:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar permisos de miembro
  async updateMemberPermissions(req, res) {
    try {
      const { id, userId } = req.params;
      const { permissions } = req.body;

      const project = await Project.findById(id);
      if (!project || !project.isActive) {
        return sendError(res, 404, 'Proyecto no encontrado');
      }

      // Solo owner puede cambiar permisos
      if (project.owner.toString() !== req.user.userId) {
        return sendError(res, 403, 'Solo el propietario puede cambiar permisos');
      }

      const memberIndex = project.members.findIndex(
        member => member.user.toString() === userId
      );

      if (memberIndex === -1) {
        return sendError(res, 400, 'Usuario no es miembro del proyecto');
      }

      project.members[memberIndex].permissions = {
        ...project.members[memberIndex].permissions,
        ...permissions
      };

      await project.save();

      sendResponse(res, 200, true, 'Permisos actualizados exitosamente', {
        member: project.members[memberIndex]
      });
    } catch (error) {
      console.error('Error actualizar permisos:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Helper: Obtener estad√≠sticas del usuario
  async getProjectStats(userId) {
    try {
      const totalProjects = await Project.countDocuments({
        $or: [{ owner: userId }, { 'members.user': userId }],
        isActive: true
      });

      const ownedProjects = await Project.countDocuments({
        owner: userId,
        isActive: true
      });

      const memberProjects = totalProjects - ownedProjects;

      const overdueProjects = await Project.countDocuments({
        $or: [{ owner: userId }, { 'members.user': userId }],
        isActive: true,
        endDate: { $lt: new Date() }
      });

      return {
        total: totalProjects,
        owned: ownedProjects,
        member: memberProjects,
        overdue: overdueProjects
      };
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas:', error);
      return { total: 0, owned: 0, member: 0, overdue: 0 };
    }
  }

  // Helper: Permisos por rol
  getPermissionsByRole(roleName) {
    switch(roleName) {
      case 'Admin':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: true,
          canAssignTasks: true
        };
      case 'Project Manager':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: true,
          canAssignTasks: true
        };
      case 'Developer':
        return {
          canCreateTasks: true,
          canEditTasks: true,
          canDeleteTasks: false,
          canAssignTasks: false
        };
      default:
        return {
          canCreateTasks: false,
          canEditTasks: false,
          canDeleteTasks: false,
          canAssignTasks: false
        };
    }
  }
}

module.exports = new ProjectController();

// ===================================
// src/routes/project.routes.js
// ===================================
const express = require('express');
const router = express.Router();
const projectController = require('../controllers/project.controller');
const { 
  validateProject, 
  validateMember, 
  validateStatus,
  validateSettings,
  validatePermissions
} = require('../validators/project.validator');
const { authenticate } = require('../middlewares/auth.middleware');
const { authorize } = require('../middlewares/role.middleware');
const { handleValidation } = require('../middlewares/validation.middleware');

// Todas las rutas requieren autenticaci√≥n
router.use(authenticate);

// Rutas principales
router.get('/', projectController.getProjects);
router.post('/', 
  authorize(['Admin', 'Project Manager']), 
  validateProject, 
  handleValidation, 
  projectController.createProject
);
router.get('/:id', projectController.getProject);
router.put('/:id', 
  validateProject, 
  handleValidation, 
  projectController.updateProject
);
router.delete('/:id', 
  authorize(['Admin']), 
  projectController.deleteProject
);

// Gesti√≥n de miembros
router.post('/:id/members', 
  validateMember, 
  handleValidation, 
  projectController.addMember
);
router.delete('/:id/members/:userId', 
  projectController.removeMember
);
router.put('/:id/members/:userId/permissions',
  validatePermissions,
  handleValidation,
  projectController.updateMemberPermissions
);

// Estado y configuraciones
router.put('/:id/status', 
  validateStatus, 
  handleValidation, 
  projectController.changeStatus
);
router.put('/:id/settings',
  validateSettings,
  handleValidation,
  projectController.updateSettings
);

module.exports = router;

// ===================================
// src/validators/project.validator.js
// ===================================
const { body, param } = require('express-validator');

const validateProject = [
  body('name')
    .trim()
    .isLength({ min: 3, max: 100 })
    .withMessage('Nombre debe tener entre 3 y 100 caracteres'),

  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Descripci√≥n debe tener entre 10 y 1000 caracteres'),

  body('category')
    .isMongoId()
    .withMessage('ID de categor√≠a inv√°lido'),

  body('startDate')
    .isISO8601()
    .withMessage('Fecha de inicio inv√°lida'),

  body('endDate')
    .isISO8601()
    .withMessage('Fecha de fin inv√°lida')
    .custom((endDate, { req }) => {
      if (new Date(endDate) <= new Date(req.body.startDate)) {
        throw new Error('Fecha de fin debe ser posterior al inicio');
      }
      return true;
    }),

  body('estimatedHours')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Horas estimadas deben ser positivas'),

  body('budget')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Presupuesto debe ser positivo'),

  body('priority')
    .optional()
    .isIn(['Low', 'Medium', 'High', 'Critical'])
    .withMessage('Prioridad inv√°lida'),

  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags deben ser un array'),

  body('tags.*')
    .optional()
    .trim()
    .isLength({ min: 1, max: 20 })
    .withMessage('Cada tag debe tener entre 1 y 20 caracteres'),

  body('settings')
    .optional()
    .isObject()
    .withMessage('Settings debe ser un objeto'),

  body('settings.allowComments')
    .optional()
    .isBoolean()
    .withMessage('allowComments debe ser booleano'),

  body('settings.allowTaskCreation')
    .optional()
    .isBoolean()
    .withMessage('allowTaskCreation debe ser booleano'),

  body('settings.requireTaskApproval')
    .optional()
    .isBoolean()
    .withMessage('requireTaskApproval debe ser booleano'),

  body('settings.notifyOnTaskComplete')
    .optional()
    .isBoolean()
    .withMessage('notifyOnTaskComplete debe ser booleano'),

  body('settings.aiAssistEnabled')
    .optional()
    .isBoolean()
    .withMessage('aiAssistEnabled debe ser booleano')
];

const validateMember = [
  body('user')
    .isMongoId()
    .withMessage('ID de usuario inv√°lido'),

  body('role')
    .isMongoId()
    .withMessage('ID de rol inv√°lido'),

  body('permissions')
    .optional()
    .isObject()
    .withMessage('Permisos debe ser un objeto'),

  body('permissions.canCreateTasks')
    .optional()
    .isBoolean()
    .withMessage('canCreateTasks debe ser booleano'),

  body('permissions.canEditTasks')
    .optional()
    .isBoolean()
    .withMessage('canEditTasks debe ser booleano'),

  body('permissions.canDeleteTasks')
    .optional()
    .isBoolean()
    .withMessage('canDeleteTasks debe ser booleano'),

  body('permissions.canAssignTasks')
    .optional()
    .isBoolean()
    .withMessage('canAssignTasks debe ser booleano')
];

const validateStatus = [
  body('status')
    .isMongoId()
    .withMessage('ID de estado inv√°lido')
];

const validateSettings = [
  body('settings')
    .isObject()
    .withMessage('Settings es requerido y debe ser un objeto'),

  body('settings.allowComments')
    .optional()
    .isBoolean()
    .withMessage('allowComments debe ser booleano'),

  body('settings.allowTaskCreation')
    .optional()
    .isBoolean()
    .withMessage('allowTaskCreation debe ser booleano'),

  body('settings.requireTaskApproval')
    .optional()
    .isBoolean()
    .withMessage('requireTaskApproval debe ser booleano'),

  body('settings.notifyOnTaskComplete')
    .optional()
    .isBoolean()
    .withMessage('notifyOnTaskComplete debe ser booleano'),

  body('settings.aiAssistEnabled')
    .optional()
    .isBoolean()
    .withMessage('aiAssistEnabled debe ser booleano')
];

const validatePermissions = [
  body('permissions')
    .isObject()
    .withMessage('Permisos es requerido y debe ser un objeto'),

  body('permissions.canCreateTasks')
    .optional()
    .isBoolean()
    .withMessage('canCreateTasks debe ser booleano'),

  body('permissions.canEditTasks')
    .optional()
    .isBoolean()
    .withMessage('canEditTasks debe ser booleano'),

  body('permissions.canDeleteTasks')
    .optional()
    .isBoolean()
    .withMessage('canDeleteTasks debe ser booleano'),

  body('permissions.canAssignTasks')
    .optional()
    .isBoolean()
    .withMessage('canAssignTasks debe ser booleano')
];

module.exports = {
  validateProject,
  validateMember,
  validateStatus,
  validateSettings,
  validatePermissions
};

// ===================================
// tests/project.test.js
// ===================================
const request = require('supertest');
const app = require('../server');
const Project = require('../src/models/Project.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const User = require('../src/models/User.model');
const Role = require('../src/models/Role.model');

describe('Project Endpoints', () => {
  let authToken;
  let testUser;
  let testCategory;
  let testState;
  let pmRole;

  beforeAll(async () => {
    // Crear rol PM
    pmRole = await Role.create({
      name: 'Project Manager',
      description: 'Gestor de proyectos'
    });

    // Crear usuario
    testUser = await User.create({
      firstName: 'Test',
      lastName: 'PM',
      email: 'pm@test.com',
      password: 'password123',
      globalRole: pmRole._id,
      isEmailVerified: true
    });

    // Crear categor√≠a
    testCategory = await Category.create({
      name: 'Test Category',
      description: 'Categor√≠a de prueba',
      createdBy: testUser._id
    });

    // Crear estado
    testState = await State.create({
      name: 'Planificaci√≥n',
      type: 'Project',
      description: 'Estado inicial'
    });

    // Login
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'pm@test.com',
        password: 'password123'
      });

    authToken = loginResponse.body.data.token;
  });

  beforeEach(async () => {
    await Project.deleteMany({});
  });

  describe('POST /api/projects', () => {
    test('Should create a new project with default settings', async () => {
      const projectData = {
        name: 'Test Project',
        description: 'This is a test project description with enough characters',
        category: testCategory._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        estimatedHours: 100,
        budget: 5000,
        priority: 'High',
        tags: ['test', 'demo']
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(projectData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.project.name).toBe(projectData.name);
      expect(response.body.data.project.settings.allowComments).toBe(true);
      expect(response.body.data.project.settings.aiAssistEnabled).toBe(true);
    });

    test('Should create project with custom settings', async () => {
      const projectData = {
        name: 'Custom Settings Project',
        description: 'Project with custom settings for testing',
        category: testCategory._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        settings: {
          allowComments: false,
          requireTaskApproval: true,
          aiAssistEnabled: false
        }
      };

      const response = await request(app)
        .post('/api/projects')
        .set('Authorization', `Bearer ${authToken}`)
        .send(projectData);

      expect(response.status).toBe(201);
      expect(response.body.data.project.settings.allowComments).toBe(false);
      expect(response.body.data.project.settings.requireTaskApproval).toBe(true);
      expect(response.body.data.project.settings.aiAssistEnabled).toBe(false);
    });
  });

  describe('GET /api/projects', () => {
    beforeEach(async () => {
      await Project.create({
        name: 'Test Project',
        description: 'Test project description for listing',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }]
      });
    });

    test('Should get user projects with stats', async () => {
      const response = await request(app)
        .get('/api/projects')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.projects).toHaveLength(1);
      expect(response.body.data.stats).toBeDefined();
      expect(response.body.data.stats.total).toBe(1);
    });
  });

  describe('POST /api/projects/:id/members', () => {
    let testProject;
    let newUser;
    let devRole;

    beforeEach(async () => {
      // Crear rol developer
      devRole = await Role.findOne({ name: 'Developer' }) ||
                await Role.create({ name: 'Developer', description: 'Developer role' });

      // Crear nuevo usuario
      newUser = await User.create({
        firstName: 'New',
        lastName: 'Developer',
        email: 'dev@test.com',
        password: 'password123',
        globalRole: devRole._id
      });

      // Crear proyecto
      testProject = await Project.create({
        name: 'Test Project',
        description: 'Test description for member testing',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }]
      });
    });

    test('Should add member with custom permissions', async () => {
      const memberData = {
        user: newUser._id,
        role: devRole._id,
        permissions: {
          canCreateTasks: true,
          canEditTasks: false,
          canDeleteTasks: false,
          canAssignTasks: false
        }
      };

      const response = await request(app)
        .post(`/api/projects/${testProject._id}/members`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(memberData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.project.members).toHaveLength(2);
    });
  });

  describe('PUT /api/projects/:id/settings', () => {
    let testProject;

    beforeEach(async () => {
      testProject = await Project.create({
        name: 'Settings Test Project',
        description: 'Project for testing settings updates',
        category: testCategory._id,
        owner: testUser._id,
        status: testState._id,
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        members: [{
          user: testUser._id,
          role: pmRole._id
        }]
      });
    });

    test('Should update project settings', async () => {
      const newSettings = {
        settings: {
          allowComments: false,
          requireTaskApproval: true,
          aiAssistEnabled: false
        }
      };

      const response = await request(app)
        .put(`/api/projects/${testProject._id}/settings`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(newSettings);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.settings.allowComments).toBe(false);
      expect(response.body.data.settings.requireTaskApproval).toBe(true);
    });
  });
});

// ===================================
// scripts/seed-projects.js
// ===================================
const mongoose = require('mongoose');
const Project = require('../src/models/Project.model');
const User = require('../src/models/User.model');
const Category = require('../src/models/Category.model');
const State = require('../src/models/State.model');
const Role = require('../src/models/Role.model');
require('dotenv').config();

const seedProjects = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Conectado a MongoDB para seed de proyectos');

    // Obtener datos necesarios
    const adminUser = await User.findOne({ email: 'admin@test.com' });
    const webCategory = await Category.findOne({ name: 'Web Development' }) ||
                       await Category.create({
                         name: 'Web Development',
                         description: 'Desarrollo de aplicaciones web',
                         createdBy: adminUser._id
                       });

    const planningState = await State.findOne({ name: 'Planificaci√≥n', type: 'Project' });
    const progressState = await State.findOne({ name: 'En Progreso', type: 'Project' });
    const pmRole = await Role.findOne({ name: 'Project Manager' });
    const devRole = await Role.findOne({ name: 'Developer' });

    const sampleProjects = [
      {
        name: 'E-commerce Platform',
        description: 'Desarrollo de plataforma de comercio electr√≥nico con React y Node.js. Incluye carrito de compras, pagos en l√≠nea, gesti√≥n de inventario y panel de administraci√≥n.',
        category: webCategory._id,
        owner: adminUser._id,
        status: progressState._id,
        priority: 'High',
        startDate: new Date('2024-01-15'),
        endDate: new Date('2024-06-30'),
        estimatedHours: 500,
        budget: 25000,
        tags: ['react', 'nodejs', 'ecommerce', 'stripe'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: false,
          notifyOnTaskComplete: true,
          aiAssistEnabled: true
        },
        aiMetadata: {
          healthScore: 75,
          riskLevel: 'Medium',
          recommendations: [
            'Revisar cronograma de desarrollo',
            'Aumentar cobertura de testing',
            'Implementar CI/CD pipeline'
          ]
        }
      },
      {
        name: 'Mobile Banking App',
        description: 'Aplicaci√≥n m√≥vil para banca digital con autenticaci√≥n biom√©trica, transferencias, pagos y gesti√≥n de cuentas.',
        category: webCategory._id,
        owner: adminUser._id,
        status: planningState._id,
        priority: 'Critical',
        startDate: new Date('2024-03-01'),
        endDate: new Date('2024-12-31'),
        estimatedHours: 800,
        budget: 50000,
        tags: ['mobile', 'banking', 'security', 'flutter'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: true,
          notifyOnTaskComplete: true,
          aiAssistEnabled: true
        },
        aiMetadata: {
          healthScore: 20,
          riskLevel: 'Low',
          recommendations: [
            'Definir arquitectura de seguridad',
            'Seleccionar stack tecnol√≥gico',
            'Crear wireframes y prototipos'
          ]
        }
      },
      {
        name: 'Company Intranet',
        description: 'Sistema interno para gesti√≥n de empleados, documentos, comunicaci√≥n interna y recursos humanos.',
        category: webCategory._id,
        owner: adminUser._id,
        status: progressState._id,
        priority: 'Medium',
        startDate: new Date('2024-02-01'),
        endDate: new Date('2024-08-15'),
        estimatedHours: 300,
        budget: 15000,
        tags: ['intranet', 'hr', 'internal', 'vue'],
        members: [{
          user: adminUser._id,
          role: pmRole._id,
          permissions: {
            canCreateTasks: true,
            canEditTasks: true,
            canDeleteTasks: true,
            canAssignTasks: true
          }
        }],
        settings: {
          allowComments: true,
          allowTaskCreation: true,
          requireTaskApproval: false,
          notifyOnTaskComplete: false,
          aiAssistEnabled: false
        },
        aiMetadata: {
          healthScore: 60,
          riskLevel: 'Low',
          recommendations: [
            'Integrar con sistema de RRHH existente',
            'Mejorar UX del dashboard'
          ]
        }
      }
    ];

    // Limpiar proyectos existentes
    await Project.deleteMany({});

    // Crear proyectos de ejemplo
    for (const projectData of sampleProjects) {
      const project = await Project.create(projectData);
      console.log(`‚úÖ Proyecto creado: ${project.name}`);
    }

    console.log('üéâ Seed de proyectos completado exitosamente');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error en seed de proyectos:', error);
    process.exit(1);
  }
};

if (require.main === module) {
  seedProjects();
}

module.exports = seedProjects;

// ===================================
// Actualizaci√≥n necesaria en server.js
// ===================================

/*
AGREGAR ESTA L√çNEA EN server.js DESPU√âS DE LAS RUTAS EXISTENTES:

// Rutas existentes...
app.use('/api/auth', require('./src/routes/auth.routes'));
app.use('/api/users', require('./src/routes/user.routes'));
app.use('/api/roles', require('./src/routes/role.routes'));
app.use('/api/categories', require('./src/routes/category.routes'));
app.use('/api/states', require('./src/routes/state.routes'));
app.use('/api/upload', require('./src/routes/upload.routes'));

// ‚úÖ NUEVA RUTA DE MARIANA:
app.use('/api/projects', require('./src/routes/project.routes'));

// Las rutas de Maryamm se agregar√°n despu√©s:
// app.use('/api/tasks', require('./src/routes/task.routes'));
// app.use('/api/comments', require('./src/routes/comment.routes'));
// app.use('/api/ai', require('./src/routes/ai.routes'));
*/

// ===================================
// DOCUMENTACI√ìN DE INTEGRACI√ìN
// ===================================

/*
üîó INTEGRACI√ìN CON MARYAMM:

1. CAMPOS PREPARADOS PARA TASKS:
   - members[].permissions.canCreateTasks
   - members[].permissions.canEditTasks
   - members[].permissions.canDeleteTasks
   - members[].permissions.canAssignTasks
   - settings.allowTaskCreation
   - settings.requireTaskApproval
   - settings.notifyOnTaskComplete

2. CAMPOS PREPARADOS PARA COMMENTS:
   - settings.allowComments

3. CAMPOS PREPARADOS PARA IA:
   - settings.aiAssistEnabled
   - aiMetadata.healthScore
   - aiMetadata.riskLevel
   - aiMetadata.recommendations
   - aiMetadata.lastAnalysis

4. VIRTUALS DISPONIBLES:
   - taskCount (conteo de tareas)
   - commentCount (conteo de comentarios)
   - progress (progreso basado en tareas)
   - isOverdue (proyecto retrasado)

5. M√âTODOS HELPER:
   - updateProgressFromTasks() (actualizar progreso desde tareas)
   - getPermissionsByRole() (permisos por rol)

6. ENDPOINTS LISTOS:
   - PUT /api/projects/:id/settings (configurar IA/tasks/comments)
   - PUT /api/projects/:id/members/:userId/permissions (permisos de tareas)

7. CAMPOS POPULADOS EN RELACIONES:
   - Virtual taskCount y commentCount autom√°ticamente populados
   - Members con permisos espec√≠ficos para cada usuario

üöÄ ¬°LISTO PARA INTEGRACI√ìN PERFECTA CON MARYAMM!
*/