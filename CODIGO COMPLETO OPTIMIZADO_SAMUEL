// ===================================
// SAMUEL GOMEZ - C√ìDIGO COMPLETO OPTIMIZADO
// M√≥dulo: Autenticaci√≥n, Usuarios y Roles
// ===================================

// server.js - Configuraci√≥n Principal
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const app = express();

// Middlewares globales
app.use(helmet());
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // 100 requests por ventana
  message: { success: false, message: 'Demasiadas peticiones desde esta IP' }
});
app.use('/api/', limiter);

// Rutas
app.use('/api/auth', require('./src/routes/auth.routes'));
app.use('/api/users', require('./src/routes/user.routes'));
app.use('/api/roles', require('./src/routes/role.routes'));

// Middleware de errores
app.use(require('./src/middlewares/error.middleware'));

// Conexi√≥n MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/project_management')
  .then(() => console.log('‚úÖ MongoDB conectado'))
  .catch(err => console.error('‚ùå Error MongoDB:', err));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Servidor en puerto ${PORT}`));

module.exports = app;

// ===================================
// src/models/User.model.js
// ===================================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    trim: true,
    maxlength: 50
  },
  lastName: {
    type: String,
    required: true,
    trim: true,
    maxlength: 50
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    match: /^\S+@\S+\.\S+$/
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
    select: false
  },
  avatar: {
    type: String,
    default: null
  },
  phone: {
    type: String,
    match: /^\+?[\d\s-()]+$/
  },
  globalRole: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Role',
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  isEmailVerified: {
    type: Boolean,
    default: false
  },
  lastLogin: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true }
});

// Virtual nombre completo
userSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});

// Hash password antes de guardar
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// M√©todo para comparar password
userSchema.methods.comparePassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

// √çndices
userSchema.index({ email: 1 });
userSchema.index({ globalRole: 1 });

module.exports = mongoose.model('User', userSchema);

// ===================================
// src/models/Role.model.js
// ===================================
const mongoose = require('mongoose');

const roleSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true,
    enum: ['Admin', 'Project Manager', 'Developer', 'Viewer'],
    trim: true
  },
  description: {
    type: String,
    required: true,
    maxlength: 200
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

roleSchema.index({ name: 1 });

module.exports = mongoose.model('Role', roleSchema);

// ===================================
// src/controllers/auth.controller.js
// ===================================
const User = require('../models/User.model');
const Role = require('../models/Role.model');
const jwt = require('jsonwebtoken');
const { sendResponse, sendError } = require('../utils/response.util');

class AuthController {
  // Registro
  async register(req, res) {
    try {
      const { firstName, lastName, email, password, phone } = req.body;

      // Verificar email √∫nico
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return sendError(res, 400, 'El email ya est√° registrado');
      }

      // Rol por defecto
      let defaultRole = await Role.findOne({ name: 'Developer' });
      if (!defaultRole) {
        defaultRole = await Role.create({
          name: 'Developer',
          description: 'Desarrollador con permisos b√°sicos'
        });
      }

      // Crear usuario
      const user = await User.create({
        firstName,
        lastName,
        email,
        password,
        phone,
        globalRole: defaultRole._id
      });

      sendResponse(res, 201, true, 'Usuario registrado exitosamente', {
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          fullName: user.fullName
        }
      });
    } catch (error) {
      console.error('Error registro:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Login
  async login(req, res) {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({ email, isActive: true })
        .select('+password')
        .populate('globalRole');

      if (!user || !(await user.comparePassword(password))) {
        return sendError(res, 401, 'Credenciales inv√°lidas');
      }

      // Generar token
      const token = jwt.sign(
        { 
          userId: user._id,
          email: user.email,
          role: user.globalRole.name
        },
        process.env.JWT_SECRET || 'defaultsecret',
        { expiresIn: process.env.JWT_EXPIRE || '7d' }
      );

      // Actualizar √∫ltimo login
      user.lastLogin = Date.now();
      await user.save();

      sendResponse(res, 200, true, 'Login exitoso', {
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          avatar: user.avatar,
          role: user.globalRole.name,
          fullName: user.fullName
        },
        token
      });
    } catch (error) {
      console.error('Error login:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Refresh token
  async refresh(req, res) {
    try {
      const user = await User.findById(req.user.userId).populate('globalRole');
      
      const newToken = jwt.sign(
        { 
          userId: user._id,
          email: user.email,
          role: user.globalRole.name
        },
        process.env.JWT_SECRET || 'defaultsecret',
        { expiresIn: process.env.JWT_EXPIRE || '7d' }
      );

      sendResponse(res, 200, true, 'Token renovado', { token: newToken });
    } catch (error) {
      console.error('Error refresh:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Logout
  async logout(req, res) {
    sendResponse(res, 200, true, 'Logout exitoso');
  }

  // Forgot password
  async forgotPassword(req, res) {
    sendResponse(res, 200, true, 'Email de recuperaci√≥n enviado');
  }

  // Reset password
  async resetPassword(req, res) {
    sendResponse(res, 200, true, 'Contrase√±a restablecida exitosamente');
  }
}

module.exports = new AuthController();

// ===================================
// src/controllers/user.controller.js
// ===================================
const User = require('../models/User.model');
const Role = require('../models/Role.model');
const { sendResponse, sendError } = require('../utils/response.util');

class UserController {
  // Listar usuarios (Admin)
  async getUsers(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;

      const users = await User.find({ isActive: true })
        .populate('globalRole', 'name description')
        .select('-password')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 });

      const total = await User.countDocuments({ isActive: true });

      sendResponse(res, 200, true, 'Usuarios obtenidos', {
        users,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      });
    } catch (error) {
      console.error('Error usuarios:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Perfil usuario actual
  async getProfile(req, res) {
    try {
      const user = await User.findById(req.user.userId)
        .populate('globalRole', 'name description')
        .select('-password');

      sendResponse(res, 200, true, 'Perfil obtenido', { user });
    } catch (error) {
      console.error('Error perfil:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar perfil
  async updateProfile(req, res) {
    try {
      const { firstName, lastName, phone } = req.body;
      
      const user = await User.findByIdAndUpdate(
        req.user.userId,
        { firstName, lastName, phone },
        { new: true, runValidators: true }
      ).populate('globalRole', 'name description');

      sendResponse(res, 200, true, 'Perfil actualizado', { user });
    } catch (error) {
      console.error('Error actualizar perfil:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Eliminar usuario (Admin)
  async deleteUser(req, res) {
    try {
      const { id } = req.params;

      await User.findByIdAndUpdate(id, { isActive: false });

      sendResponse(res, 200, true, 'Usuario eliminado');
    } catch (error) {
      console.error('Error eliminar usuario:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Cambiar rol (Admin)
  async changeRole(req, res) {
    try {
      const { id } = req.params;
      const { roleId } = req.body;

      const user = await User.findByIdAndUpdate(
        id,
        { globalRole: roleId },
        { new: true }
      ).populate('globalRole', 'name description');

      sendResponse(res, 200, true, 'Rol actualizado', { user });
    } catch (error) {
      console.error('Error cambiar rol:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }
}

module.exports = new UserController();

// ===================================
// src/controllers/role.controller.js
// ===================================
const Role = require('../models/Role.model');
const { sendResponse, sendError } = require('../utils/response.util');

class RoleController {
  // Listar roles
  async getRoles(req, res) {
    try {
      const roles = await Role.find({ isActive: true }).sort({ name: 1 });
      sendResponse(res, 200, true, 'Roles obtenidos', { roles });
    } catch (error) {
      console.error('Error roles:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Crear rol (Admin)
  async createRole(req, res) {
    try {
      const { name, description } = req.body;

      const role = await Role.create({ name, description });

      sendResponse(res, 201, true, 'Rol creado', { role });
    } catch (error) {
      console.error('Error crear rol:', error);
      if (error.code === 11000) {
        return sendError(res, 400, 'El rol ya existe');
      }
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Actualizar rol (Admin)
  async updateRole(req, res) {
    try {
      const { id } = req.params;
      const { name, description } = req.body;

      const role = await Role.findByIdAndUpdate(
        id,
        { name, description },
        { new: true, runValidators: true }
      );

      if (!role) {
        return sendError(res, 404, 'Rol no encontrado');
      }

      sendResponse(res, 200, true, 'Rol actualizado', { role });
    } catch (error) {
      console.error('Error actualizar rol:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }

  // Eliminar rol (Admin)
  async deleteRole(req, res) {
    try {
      const { id } = req.params;

      await Role.findByIdAndUpdate(id, { isActive: false });

      sendResponse(res, 200, true, 'Rol eliminado');
    } catch (error) {
      console.error('Error eliminar rol:', error);
      sendError(res, 500, 'Error interno del servidor');
    }
  }
}

module.exports = new RoleController();

// ===================================
// src/routes/auth.routes.js
// ===================================
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');
const { validateRegister, validateLogin } = require('../validators/auth.validator');
const { authenticate } = require('../middlewares/auth.middleware');
const { handleValidation } = require('../middlewares/validation.middleware');

router.post('/register', validateRegister, handleValidation, authController.register);
router.post('/login', validateLogin, handleValidation, authController.login);
router.post('/refresh', authenticate, authController.refresh);
router.post('/logout', authController.logout);
router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password', authController.resetPassword);

module.exports = router;

// ===================================
// src/routes/user.routes.js
// ===================================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const { validateProfile, validateRole } = require('../validators/user.validator');
const { authenticate } = require('../middlewares/auth.middleware');
const { authorize } = require('../middlewares/role.middleware');
const { handleValidation } = require('../middlewares/validation.middleware');

// Todas requieren autenticaci√≥n
router.use(authenticate);

router.get('/', authorize(['Admin']), userController.getUsers);
router.get('/profile', userController.getProfile);
router.put('/profile', validateProfile, handleValidation, userController.updateProfile);
router.delete('/:id', authorize(['Admin']), userController.deleteUser);
router.put('/:id/role', authorize(['Admin']), validateRole, handleValidation, userController.changeRole);

module.exports = router;

// ===================================
// src/routes/role.routes.js
// ===================================
const express = require('express');
const router = express.Router();
const roleController = require('../controllers/role.controller');
const { validateRole } = require('../validators/role.validator');
const { authenticate } = require('../middlewares/auth.middleware');
const { authorize } = require('../middlewares/role.middleware');
const { handleValidation } = require('../middlewares/validation.middleware');

router.use(authenticate);

router.get('/', roleController.getRoles);
router.post('/', authorize(['Admin']), validateRole, handleValidation, roleController.createRole);
router.put('/:id', authorize(['Admin']), validateRole, handleValidation, roleController.updateRole);
router.delete('/:id', authorize(['Admin']), roleController.deleteRole);

module.exports = router;

// ===================================
// src/middlewares/auth.middleware.js
// ===================================
const jwt = require('jsonwebtoken');
const User = require('../models/User.model');
const { sendError } = require('../utils/response.util');

const authenticate = async (req, res, next) => {
  try {
    let token;

    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
      return sendError(res, 401, 'Token requerido');
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'defaultsecret');

    const user = await User.findById(decoded.userId)
      .populate('globalRole')
      .select('-password');

    if (!user?.isActive) {
      return sendError(res, 401, 'Token inv√°lido');
    }

    req.user = { ...decoded, globalRole: user.globalRole };
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return sendError(res, 401, 'Token inv√°lido');
    }
    if (error.name === 'TokenExpiredError') {
      return sendError(res, 401, 'Token expirado');
    }
    sendError(res, 500, 'Error de autenticaci√≥n');
  }
};

module.exports = { authenticate };

// ===================================
// src/middlewares/role.middleware.js
// ===================================
const { sendError } = require('../utils/response.util');

const authorize = (allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return sendError(res, 401, 'No autenticado');
    }

    const userRole = req.user.globalRole?.name || req.user.role;
    
    if (!allowedRoles.includes(userRole)) {
      return sendError(res, 403, 'Sin permisos suficientes');
    }

    next();
  };
};

module.exports = { authorize };

// ===================================
// src/middlewares/validation.middleware.js
// ===================================
const { validationResult } = require('express-validator');
const { sendError } = require('../utils/response.util');

const handleValidation = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const formattedErrors = errors.array().map(error => ({
      field: error.path,
      message: error.msg,
      value: error.value
    }));

    return sendError(res, 400, 'Errores de validaci√≥n', formattedErrors);
  }
  
  next();
};

module.exports = { handleValidation };

// ===================================
// src/middlewares/error.middleware.js
// ===================================
const { sendError } = require('../utils/response.util');

const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);

  // Error de validaci√≥n Mongoose
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(error => ({
      field: error.path,
      message: error.message
    }));
    return sendError(res, 400, 'Errores de validaci√≥n', errors);
  }

  // Error de duplicado MongoDB
  if (err.code === 11000) {
    return sendError(res, 400, 'Recurso ya existe');
  }

  // Error de casting Mongoose
  if (err.name === 'CastError') {
    return sendError(res, 400, 'ID inv√°lido');
  }

  // Error por defecto
  sendError(res, 500, 'Error interno del servidor');
};

module.exports = errorHandler;

// ===================================
// src/utils/response.util.js
// ===================================
const sendResponse = (res, statusCode, success, message, data = null) => {
  const response = {
    success,
    message,
    timestamp: new Date().toISOString()
  };

  if (data) response.data = data;

  return res.status(statusCode).json(response);
};

const sendError = (res, statusCode, message, errors = null) => {
  const response = {
    success: false,
    message,
    timestamp: new Date().toISOString()
  };

  if (errors) response.errors = errors;

  return res.status(statusCode).json(response);
};

module.exports = { sendResponse, sendError };

// ===================================
// src/validators/auth.validator.js
// ===================================
const { body } = require('express-validator');

const validateRegister = [
  body('firstName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Nombre: 2-50 caracteres'),
  
  body('lastName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Apellido: 2-50 caracteres'),
  
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  
  body('password')
    .isLength({ min: 6 })
    .withMessage('Contrase√±a: m√≠nimo 6 caracteres'),
  
  body('phone')
    .optional()
    .matches(/^\+?[\d\s-()]+$/)
    .withMessage('Tel√©fono inv√°lido')
];

const validateLogin = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  
  body('password')
    .notEmpty()
    .withMessage('Contrase√±a requerida')
];

module.exports = { validateRegister, validateLogin };

// ===================================
// src/validators/user.validator.js
// ===================================
const { body } = require('express-validator');

const validateProfile = [
  body('firstName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Nombre: 2-50 caracteres'),
  
  body('lastName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Apellido: 2-50 caracteres'),
  
  body('phone')
    .optional()
    .matches(/^\+?[\d\s-()]+$/)
    .withMessage('Tel√©fono inv√°lido')
];

const validateRole = [
  body('roleId')
    .isMongoId()
    .withMessage('ID de rol inv√°lido')
];

module.exports = { validateProfile, validateRole };

// ===================================
// src/validators/role.validator.js
// ===================================
const { body } = require('express-validator');

const validateRole = [
  body('name')
    .trim()
    .isIn(['Admin', 'Project Manager', 'Developer', 'Viewer'])
    .withMessage('Rol inv√°lido'),
  
  body('description')
    .trim()
    .isLength({ min: 10, max: 200 })
    .withMessage('Descripci√≥n: 10-200 caracteres')
];

module.exports = { validateRole };

// ===================================
// package.json
// ===================================
{
  "name": "project-management-api",
  "version": "1.0.0",
  "description": "API de gesti√≥n de proyectos y tareas",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0",
    "express-validator": "^6.14.0",
    "cors": "^2.8.5",
    "helmet": "^6.0.0",
    "express-rate-limit": "^6.7.0",
    "dotenv": "^16.0.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.20",
    "jest": "^29.0.0"
  }
}

// ===================================
// .env
// ===================================
PORT=3000
NODE_ENV=development
MONGODB_URI=mongodb://localhost:27017/project_management
JWT_SECRET=your_super_secret_jwt_key_here_change_in_production
JWT_EXPIRE=7d
